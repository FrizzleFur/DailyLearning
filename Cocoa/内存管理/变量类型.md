## 数据类型

oc中以@开头得都是Foundation框架得NSString类型的字符串。

oc有3中数据类型：基础类型，对象类型，id类型

* 基础类型不需要加＊，包括int、float、double、和char类型
* 对象类型指的是类或协议所声明的指针类型必须要加＊
* id类型可以表示任 意类型，但一般只表示对象类型

**@interface**部分定义了类名、继承的父类、实现的协议、成员变量和成员方法等信息，主要做定义成员变量和成员方法

**@implementation**部分实现了接口部分定义的成员方法，主要做了两件事：实现成员方法，以及对成员方法的初始化

> *   初始化由它的构造函数来做，所以第一步先定义构造函数，如果没有定义构造函数就是用默认的构造函数，然后再实现方法。

## 变量类型

**实例成员变量**、**类变量**、**实例方法**、**类方法**：

> *   实例成员变量：即对象变量，不用static修饰，放在@interface里面。实例变量的初始化用实例构造函数。
> *   类变量：即静态变量，用static修饰，放在@interface上面。类变量的初始化用类构造函数。
> *   实例方法：只能被实例个体调用，用－；实例方法可以访问类变量。
> *   类方法：可以被类直接调用，用+；类方法不能访问实例成员变量。


类体的定义包括成员变量的定义和方法的定义。

1、成员变量包括实例变量和类变量；而成员方法包括实例方法、类方法，当然还有一种特殊的构造方法。

2、类变量、类方法就是类中的变量、方法，必须是静态的，要加static；故其又称静态变量、静态方法。

3、成员变量、成员方法是对象或实例中的变量、方法，不加static；

类变量：静态域，静态字段，或叫静态变量，它属于该类所有实例共有的属性，在内存中只有一个地方存储这个变量。而且所有的实例都可以修改这个类变量的值（前提是这个类变量没有被final修饰，否则是常量了），而且访问类变量的时候不用实例，直接用类就可以了。

* 类方法：和类变量一样，可以不用实例，直接用类就可以调用类方法。

* 实例变量：实例域，实例字段，或叫成员变量。

* 实例方法：或叫成员方法，必须先有实例，然后才能通过实例调用该实例方法。

* 使用方法：类方法可以直接调用类变量和类方法

*  类方法不可以直接调用实例变量和实例方法

*  类方法中没有this，因为没有实例，this不知道调用哪个实例

*  类方法可以从类里面直接访问类成员

*  实例方法可以调用类方法，访问类变量，但是不提倡这样做，会把类方法和类变量混淆成实例方法和实例变量

### 成员变量

* 成员变量用于类内部，无需与外界接触的变量，成员变量默认是protected，一般情况下，非子类对象无法访问，因为成员变量不会生成set、get方法，所以外界无法与成员变量接触成员变量是定义在｛｝号中的变量，如果变量的数据类型是一个类则称这个变量为实例变量。 因为实例变量是成员变量的一种特殊情况，所以实例变量也是类内部使用的，无需与外部接触的变量，这个也就是所谓的类私有变量　

```objc
@interface MyViewController :UIViewController
{
    UIButton *yourButton; 
    int count; 
    id data； 
} 
```

* 成员变量生存与该类的生命周期，变量存活周期跟你定义的该类实体对象一样；
* 成员变量作用域是整个实体对象；


### 实例变量

实例变量本质上就是成员变量，只是实例是针对类而言， 编译器会自动为你生成以下划线开头的实例变量 _myButton，也会自动为你生成setter，getter方法。 如果.m文件中写了@synthesize myButton，那么生成的实例变量就是myButton；如果没写@synthesize myButton，那么生成的实例变量就是_myButton

**成员变量 = 实例变量 + 基本数据类型变量**


### 属性变量

* 根据成员变量的私有性**，为了方便访问，所以就有了属性变量。属性变量的好处就是允许让其他对象访问到该变量**（因为属性创建过程中自动产生了set 和get方法）。当然，你可以设置只读或者可写等，设置方法也可自定义。所以，属性变量是用于与其他对象交互的变量。

属性：使用getter和setter方法，太繁琐。因此提出了属性的概念。在接口定义部分，使用@property关键字，定义属性后就会产生get和set方法(如果不想让人访问，可以不定义属性)属性的调用和成员变量的调用是不一样的，因此通过调用的方式可以看出来调用的是成员变量的方式还是属性的方式。

一般我们把成员变量和属性明明相同，意味着这个属性是为了这个成员变量而封装的。其实属性并不真正保存数据，而是通过属性的set方法，绑定到成员变量里去了，属性是两个方法，通过这两个方法改变成员变量的值。 属性访问用. 成员变量访问用 -> 方法访问用[]

调用方法给成员变量赋值是不会发生内存泄漏和空指针异常的；直接赋值会出问题。记住一点：通过方法或者属性来访问成员变量。不要直接使用成员变量，直接使用属性就等于使用了它的set方法。

```objc
@interface MyViewController :UIViewController 
@property (nonatomic, strong) UIButton *myButton; 
@end
```
属性变量是用于与其他对象交互的变量。**属性变量的好处就是允许让其他对象访问到该变量**（因为属性创建过程中自动产生了set 和get方法）。 当然，你可以设置只读或者可写等，设置方法也可自定义。 现在大家似乎都不怎么喜欢用成员变量来定义类的变量， 都喜欢用属性变量来定义类的变量。把需要与外部接触的变量定义在.h文件中，只在本类中使用的变量定义在.m文件中

### 局部变量

```objc
-（void）viewDidLoad 
{ 
    // 局部变量 
    NSArray *array = [[NSArray alloc] initWithObject:@“123”,nil]; 
} 
```

局部变量是根据其生存周期定义的，在源文件中的array，其生命周期是在以“{ }”为界限的代码块中，虽然它的名称与成员变量相同，但不是同一个变量


### 全局变量

定义：在@implementation外定义的变量（在@implementation中定义也是可以但是一般不这么干） 
举例： 

```objc
// 规范的
static int hu=3;// 全局变量 
NSString *str1= @"S1ViewController";// 全局变量 
@implementation S1ViewController 
@end 
```

全局变量分为两种
1）static 修饰的  也称私有全局变量，只在该源文件中可用

2）没有static 修饰的 ，在任何源文件中都可以用，注意：定义没有static的全局变量，命名一定要很独特，才能区分与其他源文件中的全局变量，如果出现跟其他源文件同名的全局变量，则会报错误

例如：
```objc
NSString*sttr1=@"S1ViewController";//全局变量  
```

在其他文件如果要用该全局变量，在前面加extern NSString*sttr1；即可使用了



## 参考

1. [成员变量、实例变量、类变量、成员方法、实例方法、类方法的区别](https://blog.csdn.net/wuha0/article/details/7084136)
2. [IOS 成员变量，属性变量，局部变量，实例变量，全局变量 详解 - CSDN博客](https://blog.csdn.net/chenshun123/article/details/52280564)
3. [iOS 成员变量，实例变量，属性变量的区别，联系 - Jenaral - 博客园](https://www.cnblogs.com/Jenaral/p/5970393.html)