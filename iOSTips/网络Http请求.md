# HTTP

[TOC]
### 二、HTTPS工作原理

HTTPS工作在客户端和服务器端之间。以上故事中，客户端可以看作为大师A，服务器端可以看作为大师B。客户端和服务器本身都会自带一些加密的算法，用于双方协商加密的选择项。
1、客户端首先会将自己支持的加密算法，打个包告诉服务器端。
2、服务器端从客户端发来的加密算法中，选出一组加密算法和HASH算法（注，HASH也属于加密），并将自己的身份信息以证书的形式发回给客户端。而证书中包含了网站的地址，加密用的公钥，以及证书的颁发机构等；
  这里有提到公钥的概念是故事中没有的。我们常见的加密算法一般是一些对称的算法，如凯撒加密；对称算法即加密用的密钥和解密用的密钥是一个。如故事中的密钥是4。还有一种加密解密算法称之为非对称算法。这种算法加密用的密钥（公钥）和解密用的密钥（私钥）是两个不同的密钥；通过公钥加密的内容一定要使用私钥才能够解密。
  这里，服务器就将自己用来加密用的公钥一同发还给客户端，而私钥则服务器保存着，用户解密客户端加密过后的内容。

3、客户端收到了服务器发来的数据包后，会做这么几件事情：
 1）验证一下证书是否合法。一般来说，证书是用来标示一个站点是否合法的标志。如果说该证书由权威的第三方颁发和签名的，则说明证书合法。
 2）如果证书合法，或者客户端接受和信任了不合法的证书，则客户端就会随机产生一串序列号，使用服务器发来的公钥进行加密。这时候，一条返回的消息就基本就绪。
 3）最后使用服务器挑选的HASH算法，将刚才的消息使用刚才的随机数进行加密，生成相应的消息校验值，与刚才的消息一同发还给服务器。

4、服务器接受到客户端发来的消息后，会做这么几件事情：
 1）使用私钥解密上面第2）中公钥加密的消息，得到客户端产生的随机序列号。
 2）使用该随机序列号，对该消息进行加密，验证的到的校验值是否与客户端发来的一致。如果一致则说明消息未被篡改，可以信任。
 3）最后，使用该随机序列号，加上之前第2步中选择的加密算法，加密一段握手消息，发还给客户端。同时HASH值也带上。

5、客户端收到服务器端的消息后，接着做这么几件事情：
 1）计算HASH值是否与发回的消息一致
 2）检查消息是否为握手消息

6、握手结束后，客户端和服务器端使用握手阶段产生的随机数以及挑选出来的算法进行对称加解密的传输。
  为什么不直接全程使用非对称加密算法进行数据传输？这个问题的答案是因为非对称算法的效率对比起对称算法来说，要低得多得多；因此往往只用在HTTPS的握手阶段。
  以下是我们一些经常使用的加密算法，是不是有熟悉的味道？
   非对称加密算法：RSA, DSA/DSS
   对称加密算法： AES, 3DES
   HASH算法：MD5, SHA1, SHA256

这就是HTTPS的基本原理，如果没有简单粗暴，请告诉我，以帮助我持续改进；如果真的简单粗暴，请告诉有需要的人，大家共同进步。


### TCP协议详解

#### TCP/IP协议分层


![](http://oc98nass3.bkt.clouddn.com/2017-09-04-15045091458482.jpg)

[TCP协议详解](http://www.jianshu.com/p/ef892323e68f)


### TCP三次握手

所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发，整个流程如下图所示：


![](http://oc98nass3.bkt.clouddn.com/2017-09-04-15045092317141.jpg)

（1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。

（2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。

（3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

简单来说，就是

1、建立连接时，客户端发送SYN包（SYN=i）到服务器，并进入到SYN-SEND状态，等待服务器确认

2、服务器收到SYN包，必须确认客户的SYN（ack=i+1）,同时自己也发送一个SYN包（SYN=k）,即SYN+ACK包，此时服务器进入SYN-RECV状态

3、客户端收到服务器的SYN+ACK包，向服务器发送确认报ACK（ack=k+1）,此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手，客户端与服务器开始传送数据。

SYN攻击：

在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：

```
#netstat -nap | grep SYN_RECV
```
#### 三次握手解析

>我老家开往北京的大巴，由于没有车站买票，所以采用直接给大巴司机打电话预定的方式订票。而大巴司机的智慧简直让我惊叹劳动人民的伟大。
>订票流程是这样子的，我们前一天上午先给司机打电话订票，司机前一天下午打电话向每一个人确认。第二天坐车的时候凭借电话号码上车。这就是活生生的三次握手。

[三次握手](https://www.zhihu.com/question/24853633/answer/114824731)

>三次握手：“喂，你听得到吗？”“我听得到呀，你听得到我吗？”“我能听到你，今天balabala……”两次握手：“喂，你听得到吗？”“我听得到呀”“喂喂，你听得到吗？”“草，我听得到呀！！！！”“你TM能不能听到我讲话啊！！喂！”“……”四次握手：“喂，你听得到吗？”“我听得到呀，你听得到我吗？”“我能听到你，你能听到我吗？”“……不想跟傻逼说话”

[三次握手：](https://www.zhihu.com/question/24853633/answer/114872771)


![](http://oc98nass3.bkt.clouddn.com/2017-06-08-14969143989779.jpg)
![](http://oc98nass3.bkt.clouddn.com/2017-06-08-14969144404963.jpg)

#### 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？

这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。

### IP

* IP（Internet Protocol， 网协） 网络之间互连的协议

* 网络互连设备，如以太网、分组交换网等，它们相互之间不能互通，不能互通的主要原因是因为它们所传送数据的基本单元（技术上称之为“帧”）的格式不同。

* IP协议实际上是一套由软件、程序组成的协议软件，它把各种不同“帧”统一转换成“网协数据包”格式

#### IP地址

* 所谓IP地址就是给每个连接在互联网上的主机分配的一个32位地址。

* 按照TCP/IP（Transport Control Protocol/Internet Protocol，传输控制协议/Internet协议）协议规定，IP地址用二进制来表示.

* 每个IP地址长32bit，比特换算成字节，就是4个字节。例如一个采用二进制形式的IP地址是一串很长的数字，人们处理起来也太费劲了。

* 为了方便人们的使用，IP地址经常被写成十进制的形式，中间使用符号“.”分开不同的字节。

* 于是，上面的IP地址可以表示为“10.0.0.1”。IP地址的这种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多。

* IP地址是IP网络中数据传输的依据，它标识了IP网络中的一个连接，一台主机可以有多个IP地址。IP分组中的IP地址在网络传输中是保持不变的。

* 互联网通过IP地址告诉计算机;

* 互联网上的每一项网络流量都标有发送和接收计算机的IP地址。

* 每个计算机必须有一个 IP 地址才能够连入因特网。

* 每个 IP 包必须有一个地址才能够发送到另一台计算机。

网络上每一个节点都必须有一个独立的Internet地址（也叫做IP地址）。现在，通常使用的IP地址是一个32bit的数字，也就是我们常说的IPv4标准，这32bit的数字分成四组，也就是常见的255.255.255.255的样式。IPv4标准上，地址被分为五类，我们常用的是B类地址。具体的分类请参考其他文档。需要注意的是IP地址是网络号+主机号的组合，这非常重要。

CP/IP 使用 32 个比特来编址。一个计算机字节是 8 比特。所以 TCP/IP 使用了 4 个字节。
一个计算机字节可以包含 256 个不同的值：
00000000、00000001、00000010、00000011、00000100、00000101、00000110、00000111、00001000 ....... 直到 11111111。
现在，你知道了为什么 TCP/IP 地址是介于 0 到 255 之间的 4 个数字。

##### 地址格式：

* IP地址=网络地址+主机地址

*  IP地址=网络地址+子网地址+主机地址。

#### 本地服务器

* 在一个文件目录中启动Python 本地服务器，端口`8000`

您的浏览器发送的每个请求的条目的服务器日志：
![](http://oc98nass3.bkt.clouddn.com/15234622040759.jpg)

然后在浏览器中访问：`http://localhost:8000/ `
![](http://oc98nass3.bkt.clouddn.com/15234622850793.jpg)

这就是Python演示服务器，在自己的计算机上运行。它提供本地磁盘上的文件，以便您可以在浏览器中查看它们。

你在你的浏览器中输入`localhost8000` 时，你的浏览器向运行的Python程序发送一个HTTP请求。您的浏览器将该程序的响应数据在UI上展现。在这种情况下，它显示了一个作为一块HTML的目录列表。您还可以使用浏览器的开发工具查看它发送的HTML。

##### IP 路由器

* 当一个 IP 包从一台计算机被发送，它会到达一个 IP 路由器。

* IP 路由器负责将这个包路由至它的目的地，直接地或者通过其他的路由器。

* 在一个相同的通信中，一个包所经由的路径可能会和其他的包不同。而路由器负责根据通信量、网络中的错误或者其他参数来进行正确地寻址。

#### 域名

12 个阿拉伯数字很难记忆。使用一个名称更容易。

用于 TCP/IP 地址的名字被称为域名。w3school.com.cn 就是一个域名。

当你键入一个像 http://www.w3school.com.cn 这样的域名，域名会被一种 `DNS` 程序翻译为数字。

在全世界，数量庞大的 DNS 服务器被连入因特网。DNS 服务器负责将域名翻译为 TCP/IP 地址，同时负责使用新的域名信息更新彼此的系统。

当一个新的域名连同其 TCP/IP 地址一同注册后，全世界的 DNS 服务器都会对此信息进行更新。

##### DNS

DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。在RFC文档中RFC 2181对DNS有规范说明，RFC 2136对DNS的动态更新进行说明，RFC 2308对DNS查询的反向缓存进行说明。

#### content-type

![](http://oc98nass3.bkt.clouddn.com/2017-09-04-15045100047341.jpg)

[HTTP 请求头与请求体 - 某熊的全栈之路 - SegmentFault](https://segmentfault.com/a/1190000006689767)

content-type是必须的，它包括一个类似标志性质的名为boundary的标志，

这算是最常见的 POST 提交数据的方式了。浏览器的原生 <form> 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。请求类似于下面这样（无关的请求头在本文中都省略掉了）：

```
POST http://www.example.com HTTP/1.1
Content-Type: application/x-www-form-urlencoded;charset=utf-8
title=test&sub%5B%5D=1&sub%5B%5D=2&sub%5B%5D=3
```
首先，Content-Type 被指定为 application/x-www-form-urlencoded；这里的格式要求就是URL中Query String的格式要求：多个键值对之间用&连接，键与值之前用=连接，且只能用ASCII字符，非ASCII字符需使用UrlEncode编码。大部分服务端语言都对这种方式有很好的支持。例如 PHP 中，$_POST['title'] 可以获取到 title 的值，$_POST['sub'] 可以得到 sub 数组。

![](http://oc98nass3.bkt.clouddn.com/2017-09-04-15045099311373.jpg)


#### 文件分割

第三种请求体的请求体被分成为多个部分，文件上传时会被使用，这种格式最先应该是被用于邮件传输中，每个字段/文件都被boundary（Content-Type中指定）分成单独的段，每段以-- 加 boundary开头，然后是该段的描述头，描述头之后空一行接内容，请求结束的标制为boundary后面加--，结构见下图：

![](http://oc98nass3.bkt.clouddn.com/2017-09-04-15045099842386.jpg)

### HTML

Hypertext Markup Language 超文本链接标示语言

* 加载简单的Web页面可能需要很多个请求，需要请求不同的服务器索取资源：HTML页面本身、图像或其他媒体

* HTTP请求总是涉及客户端和服务器。

* 前端：针对浏览器的开发，代码在浏览器运行

* 后端：针对服务器的开发，代码在服务器运行

* 您现在使用的是HTTP客户端——Web浏览器。

* 您的浏览器向Web服务器发送HTTP请求，服务器将响应发送回浏览器。

![](http://oc98nass3.bkt.clouddn.com/15234610574722.jpg)

* 浏览器拥有所有的用户界面、动画和图形内容。

* 服务器只需要做一件事：处理传入的请求。

* 服务器只是一个程序，它接受来自网络上其他程序的连接。

当你启动一个服务器程序时，它会等待客户端连接到它，就像演示服务器等待Web浏览器请求页面一样。然后，当一个连接出现时，服务器运行一段代码，比如调用一个函数来处理每个传入的连接。从这个意义上说，一个连接就像一个电话：它是一个通道，通过它，客户端和服务器可以相互通信。Web客户端通过这些连接发送请求，服务器将响应发送回。


## URI

Web地址也被称为统一资源标识符的URI（Uniform Resource Identifier）。你以前见过很多这样的。从Web用户的角度来看，URI是一个文本，放在Web浏览器中，告诉它要到哪个页面。从Web开发人员的角度来看，它有点复杂。

### URL

URL: Uniform Resource Locator

URL是网络上资源的URI。由于URI稍微精确一些，不要过分担心这个区别。这里是一个例子：`https://en.wikipedia.org/wiki/fish` 这个URI有三个可见部分，用一点点标点符号隔开：

* https 是该方案Scheme；

* en.wikipedia.org 是主机名；

* wiki/fish 是路径。

不同的URI可以有不同的部分

### Scheme方案
    
URI的第一部分是该方案，它告诉客户如何访问资源。您以前见过的一些URI方案包括HTTP、HTTPS和File。File的URI告诉客户端访问本地文件系统中的文件。HTTP和HTTPS URI指向资源由Web服务器提供。

![](http://oc98nass3.bkt.clouddn.com/15236036510993.jpg)

### Hostname主机名

在一个HTTP URI方案后是一个主机名--比如：`www.udacity.com`或`localhost`，告诉客户端去连接哪个服务器。 URI中的主机名也可以是IP地址：例如，如果您在浏览器中放置了`http://216.58.194.174/`，则最终会在Google上显示。

为了连接到诸如`www.google.com`之类的网络服务器，客户端需要将主机名转换为IP地址。您的操作系统的网络配置使用域名服务（DNS:它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。）

* 从URL中找到主机名

* 寻找一个IP地址

* 通过IP的端口建立HTTP链接

* 为什么叫做主机？在网络术语中，主机是网络上一台可以提供服务的计算机。

* 当客户端向服务器请求资源时，它必须指定它想要与之通话的主机名。

#### Localhost

Localhost是指“此计算机本身”的特殊地址 - 用于客户端（如浏览器）访问自己计算机上的服务器时。主机名localhost引用这些特殊地址。

### 路径

在HTTP URI（以及许多其他）中，接下来出现的是路径，该路径标识服务器上的特定资源。服务器可以有很多资源，比如不同的网页、视频或API。路径告诉服务器客户机正在寻找的资源。

当你写一个URI没有路径，如http://udacity.com，浏览器填写默认路径，它是用一个斜线。这就是为什么http://udacity.com是http://udacity.com/相同（最后用一个斜线）。

用一个斜杠写的路径也被称为根。当你看演示服务器根URI HTTP：/本地：8000 / -你不看你的电脑的整个文件系统的根。它只是Web服务器提供的资源的根。演示服务器不会让Web浏览器访问正在运行的目录之外的文件。

### URI相对路径

```
<a href="cliffsofinsanity.png">cliffsofinsanity.png</a>
```

在这样一个没有一个方案，或一个主机名-只是一个路径。这是一个相对URI引用。它与它出现的上下文是“相对的”——具体地说，是它所在的页面。这个URI不包含服务器的主机名或端口，但浏览器可以发现从上下文。如果您单击其中一个链接，浏览器就知道它需要从同一个服务器中获取原始页面。

### URI其他部分

`#`标志称为片段。浏览器甚至不会发送到Web服务器。它让一个链接指向资源的一个特定的命名部分；在HTML页面中，它通过ID链接到一个元素。



## 端口Port

你看到的大多数网址都没有端口号。这是因为客户端通常从URI的Scheme(协议)中找出端口号。

例如，HTTP URI隐含的端口号为80，而HTTPS URI隐含的端口号为443.您的Python演示Web服务器在端口8000上运行。由于这不是默认端口，因此您必须将端口号写入它的URI。

 IP地址区分计算机，端口Port号码区分这些计算机上的程序。
 
 
## 以前后端 MVC 的开发模式

*   Model（模型层）：提供/保存数据
*   Controller（控制层）：数据处理，实现业务逻辑
*   View（视图层）：展示数据，提供用户界面

那时候前端只是后端 MVC 的 V。

![](http://oc98nass3.bkt.clouddn.com/15235259440725.jpg)



# Http解析.md

### 加密处理防止被窃听

1. 通信的加密

一种方式就是将通信加密。HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或 TLS（Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容。

用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP 通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTP Secure，超文本传输安全协议）或 HTTP over SSL。

2. 内容加密

由于 HTTP 协议中没有加密机制，那么就对 HTTP 协议传输的内容本身加密。即把 HTTP 报文里所含的内容进行加密处理。

在这种情况下，客户端需要对 HTTP 报文进行加密处理后再发送请求。

有一点必须引起注意，由于该方式不同于 SSL 或 TLS 将整个通信线路加密处理，所以内容仍有被篡改的风险。稍后我们会加以说明。



![](http://oc98nass3.bkt.clouddn.com/2017-06-08-14969149972962.jpg)


### 公钥加密，私钥解密。私钥数字签名，公钥验证。

一、公钥加密 
假设一下，我找了两个数字，一个是1，一个是2。我喜欢2这个数字，就保留起来，不告诉你们(私钥），然后我告诉大家，1是我的公钥。
我有一个文件，不能让别人看，我就用1加密了。别人找到了这个文件，但是他不知道2就是解密的私钥啊，所以他解不开，只有我可以用
数字2，就是我的私钥，来解密。这样我就可以保护数据了。
我的好朋友x用我的公钥1加密了字符a，加密后成了b，放在网上。别人偷到了这个文件，但是别人解不开，因为别人不知道2就是我的私钥，
只有我才能解密，解密后就得到a。这样，我们就可以传送加密的数据了。

 
二、私钥签名
如果我用私钥加密一段数据（当然只有我可以用私钥加密，因为只有我知道2是我的私钥），结果所有的人都看到我的内容了，因为他们都知
道我的公钥是1，那么这种加密有什么用处呢？
但是我的好朋友x说有人冒充我给他发信。怎么办呢？我把我要发的信，内容是c，用我的私钥2，加密，加密后的内容是d，发给x，再告诉他
解密看是不是c。他用我的公钥1解密，发现果然是c。
这个时候，他会想到，能够用我的公钥解密的数据，必然是用我的私钥加的密。只有我知道我得私钥，因此他就可以确认确实是我发的东西。
这样我们就能确认发送方身份了。这个过程叫做数字签名。当然具体的过程要稍微复杂一些。用私钥来加密数据，用途就是数字签名。
 
总结：公钥和私钥是成对的，它们互相解密。
公钥加密，私钥解密。
私钥数字签名，公钥验证。
 


# HTTP

* IP协议对应于网络层，TCP协议对应于传输层，而HTTP协议对应于应用层。
* socket则是对TCP/IP协议的封装和应用。
* TCP/IP协议是传输层协议，主要解决数据如何在网络中传输。
* HTTP是应用层协议，主要解决如何包装数据。
* 我们在传输数据时，可以只使用(传输层)TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容。
* socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API).通过Socket，我们才能使用TCP/IP协议。TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。

![ISO模型的七个分层](http://oc98nass3.bkt.clouddn.com/15166637371115.gif)

## Socket

我们知道两个进程如果需要进行通讯最基本的一个前提能能够唯一的标示一个进程，在本地进程通讯中我们可以使用PID来唯一标示一个进程，但PID只在本地唯一，网络中的两个进程PID冲突几率很大，这时候我们需要另辟它径了，我们知道IP层的ip地址可以唯一标示主机，而TCP层协议和端口号可以唯一标示主机的一个进程，这样我们可以利用ip地址＋协议＋端口号唯一标示网络中的一个进程。

能够唯一标示网络中的进程后，它们就可以利用socket进行通信了，什么是socket呢？我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。
![](http://oc98nass3.bkt.clouddn.com/15166639010683.jpg)

### 一.TCP/IP连接

手机能够使用联网功能是因为手机底层实现了TCP/IP协议，可以使手机终端通过无线网络建立TCP连接。TCP协议可以对上层网络提供接口，使上层网络数据的传输建立在“无差别”的网络之上。

建立起一个TCP连接需要经过“三次握手”：

```
第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。
```

握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”（过程就不细写了，就是服务器和客户端交互，最终确定断开）.

### 二.HTTP连接

HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。

HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。

在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。

在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。

由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。

三.SOCKET原理
套接字（socket）概念

套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。

应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。

建立socket连接

建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。

套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。

服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。

客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。

连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。

四.SOCKET连接与TCP/IP连接
创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。

socket则是对TCP/IP协议的封装和应用（程序员层面上）。也可以说，TPC/IP协议是传输层协议，主要解决数据 如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：

“我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如 果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也 可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。”

我们平时说的最多的socket是什么呢，实际上socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。 实际上，Socket跟TCP/IP协议没有必然的联系。Socket 编程 接口在设计的时候，就希望也能适应其他的网络协议。所以说，Socket的出现，只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口，比如create、 listen、connect、accept、send、read和write等等。网络有一段关于socket和TCP/IP协议关系的说法比较容易理解：

“TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。这个就像操作系统会提供标准的编程接口，比如win32编程接口一样，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。”

实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口。socket是对端口通信开发的工具,它要更底层一些.

五.Socket连接与HTTP连接
由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如 路由器 、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。

而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。

很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。

http协议是应用层的协义

有个比较形象的描述：HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。

两个计算机之间的交流无非是两个端口之间的数据通信,具体的数据会以什么样的形式展现是以不同的应用层协议来定义的如HTTP、FTP...


## HTTP请求Request

[关于HTTP协议，一篇就够了 - 简书](http://www.jianshu.com/p/80e25cb1d81a)

客户端发送一个HTTP请求到服务器的请求消息包括以下格式：

请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。

![](http://oc98nass3.bkt.clouddn.com/2017-09-04-15045083200378.jpg)

[简单粗暴系列之HTTPS原理](http://www.jianshu.com/p/650ad90bf563)

POST请求例子，使用Charles抓取的request：

```
POST / HTTP1.1
Host:www.wrox.com
User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
Content-Type:application/x-www-form-urlencoded
Content-Length:40
Connection: Keep-Alive

name=Professional%20Ajax&publisher=Wiley
```

* 第一部分：请求行，第一行明了是post请求，以及http1.1版本。
* 第二部分：请求头部，第二行至第六行。
* 第三部分：空行，第七行的空行。
* 第四部分：请求数据，第八行。

#### HTTP请求方法

根据HTTP标准，HTTP请求可以使用多种请求方法。
HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。
HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。

```
GET     请求指定的页面信息，并返回实体主体。
HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
PUT     从客户端向服务器传送的数据取代指定的文档的内容。
DELETE      请求服务器删除指定的页面。
CONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
OPTIONS     允许客户端查看服务器的性能。
TRACE     回显服务器收到的请求，主要用于测试或诊断。
```

### HTTP之状态码

状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:

* 200 - 请求成功
* 301 - 资源（网页等）被永久转移到其它URL
* 307	Temporary Redirect	临时重定向。与302类似。使用GET请求重定向
* 404 - 请求的资源（网页等）不存在
* 403	Forbidden	服务器理解请求客户端的请求，但是拒绝执行此请求
* 500 - 内部服务器错误
* 502	Bad Gateway	充当网关或代理的服务器，从远端服务器接收到了一个无效的请求
* 505	HTTP Version not supported	服务器不支持请求的HTTP协议的版本，无法完成处理


![](http://oc98nass3.bkt.clouddn.com/2017-06-08-14969148476130.jpg)


### GET请求
 
 举例：
 
```
127.0.0.1 - - [03/Oct/2016 15:45:50] "GET /readme.png HTTP/1.1" 200 -
```

看看日期和时间之后的部分。在这里，它说“把/ readme.png HTTP / 1.1”。这是浏览器发送给服务器的请求行的文本。本日志是服务器告诉你它收到一个请求，说，从字面上看，得到`readme.png HTTP / 1.1`。

GET请求有3各部分：

1. 单词GET是正在使用的方法或HTTP动词;这说明正在提出什么样的要求。 GET是客户端希望服务器发送资源（例如网页或图像）时使用的动词

2. `/readme.png` 是被请求资源的路径。注意，客户端没有在这里发送资源的整个URI。这并不是说，`https://localhost:8000/readme.png`。它只发送路径。

3. 最后，HTTP / 1.1是请求的协议。多年来，HTTP的工作方式发生了一些变化。客户必须告诉服务器他们说的是哪一种方言。HTTP / 1.1是当今最常见的版本。
![](http://oc98nass3.bkt.clouddn.com/15236304256994.jpg)

### POST请求

```
POST / HTTP/1.1
Host: www.wrox.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
Gecko/20050225 Firefox/1.0.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 40
Connection: Keep-Alive

name=Professional%20Ajax&publisher=Wiley
```

### 不同点

1. GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&连接；例 如：login.action?name=hyddd&password=idontknow&verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。

POST提交：把提交的数据放置在是HTTP包的包体中。上文示例中红色字体标明的就是实际的传输数据

因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变

2. 传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。

而在实际开发中存在的限制主要有：

GET: 特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。

因此对于GET提交时，传输数据就会受到URL长度的 限制。

POST: 由于不是通过URL传值，理论上数据不受 限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。

3. 安全性

POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击

4. Http get,post,soap协议都是在http上运行的

（1）get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的
查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全

（2）post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form- urlencoded。post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。
但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。

（3）soap：是http post的一个专用版本，遵循一种特殊的xml消息格式
Content-type设置为: text/xml 任何数据都可以xml化。

Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.

##### 我们看看GET和POST的区别

GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，如`EditPosts.aspx?name=test1&id=123456` .POST方法是把提交的数据放在HTTP包的Body中.

GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.

GET方式需要使用`Request.QueryString`来取得变量的值，而POST方式通过`Request.Form`来获取变量的值。

GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.


### HTTP之响应消息Response

一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。

HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。

![](http://oc98nass3.bkt.clouddn.com/2017-09-04-15045086649685.jpg)

```
HTTP/1.1 200 OK
Date: Fri, 22 May 2009 06:07:21 GMT
Content-Type: text/html; charset=UTF-8

<html>
      <head></head>
      <body>
            <!--body goes here-->
      </body>
</html>
```

* 第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。

* 第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）

* 第二部分：消息报头，用来说明客户端要使用的一些附加信息

* 第二行和第三行为消息报头，
* Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8

* 第三部分：空行，消息报头后面的空行是必须的

* 第四部分：响应正文，服务器返回给客户端的文本信息。

* 空行后面的html部分为响应正文。

1. 响应头
- Server  Apache--Coyote、1.1   //服务器类型
- Content Type image/jepg          //返回的
- Content-Length  56811  //返回数据额长度
- Date      Mon, 23 Jun 2017 GMT             //响应的时间


2. 实体内容：服务器返给客户端的具体数据，比如文件s护具


客户端 ————>   服务器

 - 请求行
 - 请求头
 - 请求体

服务器 ————>   客户端

 - 状态行
 - 响应头
 - 实体内容（响应体）


  [1]: http://images.cnitblog.com/blog/349217/201312/05230857-f49d5855f1e14a23a186737e0bec8a0f.gif


### 参考

1. [简析TCP的三次握手与四次分手](http://www.jellythink.com/archives/705)
2. [公钥，私钥和数字签名这样最好理解](http://blog.csdn.net/21aspnet/article/details/7249401)

