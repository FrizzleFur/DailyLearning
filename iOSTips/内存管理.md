
## 内存管理

### 引用计数式内存管理ARC

* ARC全称是 `Automatic Reference Counting`，是`Objective-C`的内存管理机制。简单地来说，就是代码中自动加入了`retain/release`，原先需要手动添加的用来处理内存管理的引用计数的代码可以自动地由编译器完成了。

* ARC的使用是为了解决对象retain和release匹配的问题。以前手动管理造成内存泄漏或者重复释放的问题将不复存在。

* 以前需要手动的通过retain去为对象获取内存，并用release释放内存。所以以前的操作称为MRC (`Manual Reference Counting`)。

*   自己生成的对象，自己所持有。
*   非自己生成的对象，自己也可以持有。
*   不再需要自己持有的对象时释放。
*   非自己持有的对象无法释放。

| 对象操作  | Objective-c方法 |
|---|---|
| 生成并持有对象 | alloc/new/copy/mutableCopy方法 |
| 持有对象 | retain方法 |
| 释放对象 | release方法 |
| 废弃对象 | dealloc方法 | 

Cocoa 框架中 Foundation 框架中的NSObject 类担负内存管理的职责。内存管理中的alloc/retain/release/dealloc方法分别指代NSObject类的alloc类方法，retain实例方法，

release实例方法和dealloc实例方法。

#### 1、自己生成的对象，自己所持有   

使用下面名称开头的方法名意味着自己生成的对象只有自己持有。   

*   alloc 
*   new
*   copy
*   mutaleCopy

首先看前两个： alloc   new 


```
 //使用alloc类方法就能自己生成并持有对象，指向生成并持有对象的指针被赋给变量obj
        id obj = [[NSObject alloc] init];
        
        //使用new类方法也可以生成并持有对象，所以 alloc 和 new 二者是完全一致的
        id obj = [NSObject new];
```
纠正：上面代码注释中说到alloc 和new 二者是完全一致的，这种说法是不正确的！其实应该是：[NSObject new]  和  [[NSObject alloc] init] 这两个语句的作用是一致的。

下面看一下后两个 copy  mutableCopy

这两个的理解有点复杂。

copy 方法利用 基于NSCopying 方法约定，由各类实现的 copyWithZone： 方法生成并持有对象的副本。

与copy方法类似，mutableCopy 方法利用基于 NSMutableCopying 方法约定，有各类实现的 mutableCopyWithZone： 方法生成并持有对象的副本。

两者的区别在于：

copy 方法生成不可变更的对象，而mutableCopy方法生成可变更的对象。（这样说可能有点抽象，下面用一个例子来说明！）

        1\. mutableCopy创建一个新的可变对象，并初始化为原对象的值，新对象的引用计数为 1；

        2\. copy 返回一个不可变对象。分两种情况：

        （1）若原对象是不可变对象，那么返回原对象，并将其引用计数加 1；

        （2）若原对象是可变对象，那么创建一个新的不可变对象，并初始化为原对象的值，新对象的引用计数为 1。


```
//创建一个不可变数组
        NSArray *immutableArray = [[NSArray alloc] initWithObjects:@"one",@"two",@"three", nil];
        
        //从不可变数组复制而来一个可变数组
        NSMutableArray *mutableArray = [immutableArray mutableCopy];
        [mutableArray addObject:@"four"];
        NSLog(@"count = %ld",(unsigned long)[mutableArray count]); //输出： count = 4

        NSMutableArray *array = [[NSMutableArray alloc] init];
        array = [mutableArray copy];
        //注意这里使用copy复制得到的是一个不可变的对象，尽管使用的是NSMutableArray类型。所以下面一条语句想向数组中添加元素，虽然编译成功，但是运行会出错。
        [array addObject:@"five"]; //运行出错
```

进一步说，**copy就是浅拷贝，mutableCopy就是深拷贝。**

拷贝一个对象也就是创建一个新的实例，并且初始化为拷贝源的值。

对于像boolean，integer这类值，拷贝就是直接赋值。

对于指针形的object就分为浅拷贝和深拷贝。浅拷贝是只创建一个新的指针，并指向同一块数据。深拷贝就是数据和指针都创建。 

题外话：本来是想通过  retainCount 这个实例方法来观察 引用计数值的，但是发现有一个问题：


```
    NSObject* obj = [[NSObject alloc] init];
    NSLog(@"%li",(unsigned long)[obj retainCount]); // print: 1
    [obj release];
    NSLog(@"%li",(unsigned long)[obj retainCount]); // print: 1
```

这段代码两次都是输出 1 ；第一个输出 1 ，应该没有什么问题，因为alloc 使得引用计数 +1  ；然后 release ，那么引用计数值 -1 ，那么就是应该输出 0呀！这个是为什么呢？

其实问题是这样的：

首先我们先看看文档中是如何介绍 retainCount 这个方法的：

This method is of no value in debugging memory management issues. Because any number of framework objects may have

 retained an object in order to hold references to it, while at the same time autorelease pools may be holding any number of

 deferred releases on an object, **it is very unlikely that you can get useful information from this method.**

大概的意思是：这个方法在debug的过程中是没有什么价值的（大家就不要使用啦），因为系统会延迟释放对象，所以不太可能通过这个方法得到有用的信息。

所以呢？上面最后一个语句通过 retainCount输出 引用计数值 得到的信息是不准确的，其实已经释放了对象，只不过系统延时释放而已；也就说在最后一个输出语句执行的时

候，obj 这个对象其实还没有释放（引用计数值  还不为 0），你想，要是等于 0，那系统不是直接废弃对象了吗？那么你还怎么能够调用retainCount这个实例方法。

可以这样测试一下，如果再加一个release语句的话，程序就会崩溃，要不  have  a  try ！ 这个是我的理解。

#### 2、非自己生成的对象，自己也可以持有

用 alloc  new  copy  mutableCopy 以外的方法取得的对象，因为对象不是自己生成，所有对象不归自己持有,但是可以取得对象的存在。


```
//取得对象的存在，但是自己并不持有对象
    id obj = [NSMutableArray array];
    
    //通过retain可以持有对象
    [obj retain];
```

那么通过retain方法，非自己生成的对象也可以自己持有，就像跟用 alloc  new  copy  mutableCopy 方法生成对象并持有一样。

#### 3、不再需要自己持有的对象时释放

自己持有的对象，一旦不需要，持有者有义务释放该对象，使用release方法。

```
    UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(10, 10, 100, 100)];
    [label release];
    //已经释放的对象，不可以再访问
    label.text = @"hello world";
    //运行时会崩溃
```

如果想要用某个方法生成对象，并将其返还给该方法的调用方，让调用方持有对象，如何实现呢？

```
-(id)allocObject {
    id obj = [[NSObject alloc]init];
    return obj;
}
```

注意方法的命名规则，要以`alloc  new  copy  mutableCopy`开头。

那么如果想通过某个方法取得对象的存在，而自己不持有对象，那么该如何实现呢？


```
 -(id)object {  
  id obj = [[NSObject alloc]init]; //自己持有对象  

  [obj autorelease]; //取得对象的存在，但是自己不持有对象  

  return obj;  
}
``` 

 注意方法的命名规则，不要以`alloc  new  copy  mutableCopy`开头，因为不持有对象。 

上面使用了autorelease方法，用该方法可以取得对象的存在，但自己不持有对象。autorelease提供这样的功能，使对象在超出指定的生存范围时能够自动并正确的释放（调用release方法）。

[obj autorelease]; 这个语句将obj对象注册到 autoreleasepool （自动释放缓冲池）中，在pool结束时自动调用release方法 。可以这样理解，让autoreleasepool 持有对象，让其负责对象的释放。

方法调用


```
    id obj1 = [self allocObject]; //自己持有对象
    id obj2 = [self object]; //自己不持有对象，只是取得对象存在
    //当然也可以通过retain方法持有该对象
    [obj2 retain];
```

#### 5、非自己持有的对象无法释放

对于用 alloc  new  copy  mutableCopy 方法生成并持有的对象，或者是用 retain方法持有的对象，由于持有者都是自己，所以在不需要对象时，都要调用release 释放对象，而除此之外所得到的对象绝对不能释放，倘若在程序中释放了不是自己持有的对象，那么就会造成崩溃。


```
//例子 1
    id obj1 = [self allocObject]; //自己持有对象
    [obj1 release]; //对象已经释放了
    [obj1 release]; //释放已经非自己持有的对象时，即访问已经废弃的对象，程序崩溃
    
    //例子 2
    id obj2 = [self object]; //自己不持有对象，只是取得对象存在
    [obj2 release]; //释放非自己持有的对象，程序崩溃
```
这里的 allocObject 方法和 object 方法同上。

#### 6、采用引用计数值进行内存管理的实现：

*   在objective - c 的对象中存有引用计数。
*   调用  retain 或者 alloc new  copy  mutableCopy 方法，引用计数值 +1；
*   调用release 后，引用计数值 -1；
*   引用计数值为0时，调用 dealloc 方法废弃对象。

#### 7、autorelease 

autorelease 就是自动释放，它很类似与C语言中的自动变量（局部变量）的特性。 

c语言中自动变量在程序执行过程中，若超出作用域，那么该自动变量被自动废弃。那么同理， autorelease  会像c语言中的自动变量那样来对待实例对象。当其超出作用域时，对象实例的release方法会自动被调用。

使用方法如下：

```
    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; //生成并持有NSAutoreleasePool对象
    id obj = [[NSObject alloc] init]; 
    [obj autorelease]; // 调用已经分配对象的 autorelease
    [pool drain]; // 废弃NSAutoreleasePool对象
```

最后一行的 [pool drain];  等同于  [poolrelease];

进一步说，**copy就是浅拷贝，mutableCopy就是深拷贝。**

拷贝一个对象也就是创建一个新的实例，并且初始化为拷贝源的值。
对于像boolean，integer这类值，拷贝就是直接赋值。
对于指针形的object就分为浅拷贝和深拷贝。浅拷贝是只创建一个新的指针，并指向同一块数据。深拷贝就是数据和指针都创建。

### 属性修饰

请说明并比较以下关键词：strong, weak, assign, copy

*   strong表示指向并拥有该对象。其修饰的对象引用计数会增加1。该对象只要引用计数不为0则不会被销毁。当然强行将其设为nil可以销毁它。

*   weak表示**指向但不拥有该对象。其修饰的对象引用计数不会增加**。无需手动设置，该对象会自行在内存中销毁。

*   assign主要用于修饰基本数据类型，如`NSInteger`和`CGFloat`，这些数值主要存在于栈上。

*   _weak 一般用来修饰对象，assign一般用来修饰基本数据类型_。原因是_assign修饰的对象被释放后，指针的地址依然存在，造成野指针，在堆上容易造成崩溃_。而栈上的内存系统会自动处理，不会造成野指针。

*   copy与strong类似。**不同之处是strong的复制是多个指针指向同一个地址，而copy的复制每次会在内存中拷贝一份对象，指针指向不同地址**。copy一般用在修饰有可变对应类型的不可变对象上，如NSString, NSArray, NSDictionary。

*   Objective-C 中，基本数据类型的默认关键字是atomic, readwrite, assign；普通属性的默认关键字是atomic, readwrite, strong。

2. 请说明并比较以下关键词：__weak，__block

* __weak与weak基本相同。前者用于修饰变量（variable），后者用于修饰属性（property）。__weak 主要用于防止block中的循环引用。

* __block也用于修饰变量。它是引用修饰，所以其修饰的值是动态变化的，即可以被重新赋值的。__block用于修饰某些block内部将要修改的外部变量。

* __weak和__block的使用场景几乎与block息息相关。而所谓block，就是Objective-C对于闭包的实现。闭包就是没有名字的函数，或者理解为指向函数的指针。

### 对象的内存销毁

对象的内存销毁时间表，分四个步骤：

// 对象的内存销毁时间表
// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)
// https://github.com/ChenYilong
// 根据 WWDC 2011, Session 322 (36分22秒)中发布的内存销毁时间表 

 1. 调用 -release ：引用计数变为零
     * 对象正在被销毁，生命周期即将结束.
     * 不能再有新的 __weak 弱引用， 否则将指向 nil.
     * 调用 [self dealloc] 
 2. 子类 调用 -dealloc
     * 继承关系中最底层的子类 在调用 -dealloc
     * 如果是 MRC 代码 则会手动释放实例变量们（iVars）
     * 继承关系中每一层的父类 都在调用 -dealloc
 3. NSObject 调 -dealloc
     * 只做一件事：调用 Objective-C runtime 中的 object_dispose() 方法
 4. 调用 object_dispose()
     * 为 C++ 的实例变量们（iVars）调用 destructors 
     * 为 ARC 状态下的 实例变量们（iVars） 调用 -release 
     * 解除所有使用 runtime Associate方法关联的对象
     * 解除所有 __weak 引用
     * 调用 free()



### Copy拷贝机制

#### 1\. 对非集合类对象的copy操作：

在非集合类对象中：对 immutable 对象进行 copy 操作，是指针复制，mutableCopy 操作时内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。用代码简单表示如下：

*   [immutableObject copy] // 浅复制
*   [immutableObject mutableCopy] //深复制
*   [mutableObject copy] //深复制
*   [mutableObject mutableCopy] //深复制

比如以下代码：

```source-objc
NSMutableString *string = [NSMutableString stringWithString:@"origin"];//copy
NSString *stringCopy = [string copy];
```

查看内存，会发现 string、stringCopy 内存地址都不一样，说明此时都是做内容拷贝、深拷贝。即使你进行如下操作：

```source-objc
[string appendString:@"origion!"]
```

stringCopy 的值也不会因此改变，但是如果不使用 copy，stringCopy 的值就会被改变。 集合类对象以此类推。 所以，

> 用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。



1. [集合类对象的copy与mutableCopy](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md#2%E9%9B%86%E5%90%88%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84copy%E4%B8%8Emutablecopy)2、

集合类对象是指 NSArray、NSDictionary、NSSet ... 之类的对象。下面先看集合类immutable对象使用 copy 和 mutableCopy 的一个例子：

```source-objc
NSArray *array = @[@[@"a", @"b"], @[@"c", @"d"]];
NSArray *copyArray = [array copy];
NSMutableArray *mCopyArray = [array mutableCopy];
```

查看内容，可以看到 copyArray 和 array 的地址是一样的，而 mCopyArray 和 array 的地址是不同的。说明 copy 操作进行了指针拷贝，mutableCopy 进行了内容拷贝。但需要强调的是：此处的内容拷贝，仅仅是拷贝 array 这个对象，array 集合内部的元素仍然是指针拷贝。这和上面的非集合 immutable 对象的拷贝还是挺相似的，那么mutable对象的拷贝会不会类似呢？我们继续往下，看 mutable 对象拷贝的例子：

```source-objc
NSMutableArray *array = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@"a"],@"b",@"c",nil];
NSArray *copyArray = [array copy];
NSMutableArray *mCopyArray = [array mutableCopy];
```

查看内存，如我们所料，copyArray、mCopyArray和 array 的内存地址都不一样，说明 copyArray、mCopyArray 都对 array 进行了内容拷贝。同样，我们可以得出结论：

在集合类对象中，对 immutable 对象进行 copy，是指针复制， mutableCopy 是内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。用代码简单表示如下：

```source-objc
[immutableObject copy] // 浅复制
[immutableObject mutableCopy] //单层深复制
[mutableObject copy] //单层深复制
[mutableObject mutableCopy] //单层深复制
```

这个代码结论和非集合类的非常相似。

参考链接：[iOS 集合的深复制与浅复制](https://www.zybuluo.com/MicroCai/note/50592)

### 循环引用？
循环引用是指2个或以上对象互相强引用，导致所有对象无法释放的现象。这是内存泄漏的一种情况。举个例子：

```objc
class Father

@interface Father: NSObject
@property (strong, nonatomic) Son *son;

@end

class Son

@interface Son: NSObject
@property (strong, nonatomic) Father *father; 

@end
```

上述代码有两个类，分别为爸爸和儿子。爸爸对儿子强引用，儿子对爸爸强引用。这样释放儿子必须先释放爸爸，要释放爸爸必须先释放儿子。如此一来，两个对象都无法释放。

解决方法是将Father中的Son对象属性从strong改为weak。

内存泄漏可以用Xcode中的Debug Memory Graph去检查,同时Xcode也会在runtime中自动汇报内存泄漏的问题。

