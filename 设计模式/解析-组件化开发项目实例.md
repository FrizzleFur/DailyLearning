# 解析-组件化开发项目实例


## 一个简单的记事本DEMO

架构图
![](https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/20200402140550.png)

Business代表业务组件层. 里面每个直接的组件代表一个相应的业务组件模块.  
目前有Feed, Editor, Models三个可重用组件模块.  
Feed提供列表页, 可跳转到各种详情页.  
Editor是编辑文档的详情页.  
Models是整个APP所有用到的模型, 和相应的管理类. 目前里面只有Document模型

Assembly是对应的APP集成和依赖注入代码, 对外提供封装好依赖配置的, 创建完整的组件对象. 对内使用其它Assembly提供的对象和服务, 注入依赖, 绑定输出事件  
页面间通过NavigationService跳转, 不在调用处形成强耦合, 方便集中管理和以后替换到其它的类似功能页面.  
其它一些服务只做了接口抽象, 但没弄成专门的组件. 以后有需要可以方便的再重构.  

## 一些概念和原则

### [单一职责](https://en.wikipedia.org/wiki/Single_responsibility_principle)
无论函数还是类, 都应该对应一个单一明确的模块, 有清晰的命名和职责. 最终形成大模块套小模块的树形结构

职责划分时有以下注意点:

- 职责划分清晰:  
    清晰明确的职责分配应该能通过一个良好的命名体现出来. 如果起不了一个合适的名字, 或名字过于抽象模糊, 可能暗示职责不明确, 需要拆分.

- 划分粒度:  
    应该尽量细, 如果一个模块包含多个可描述的职责, 就应该拆分成多个小模块, 委派给小模块完成相应的功能. 保持职责单一.  
    最终一个结构良好, 粒度够细的模块, 会形如大模块套小模块的树型结构. 且每个模块里代码量都不多, 实现简单直接清晰易读易重用.  
    **反例:** 非常长的方法, 类, 文件等.

- 职责边界明确:  
    职责边界限定了一个模块能影响的范围.  
    分配时应该注意: 模块应该仅能够操作自己内部的环境和变量, 以及接口传入的参数. 不应该访问甚至修改外部环境. 对外部环境有依赖的, 应该通过接口明确输入.  
    环境属于APP层拥有的状态, 所以最终使用和修改环境的代码应该收敛于最上层的APP层代码集中管理.  
    eg: 函数仅能修改传入参数. 实例方法只能修改实例内部状态, 或者发出外部事件.
        模块级代码则负责协调内部各个类工作, 形成更大的类或模块, 也只能调用内部各个类提供的接口.  
    **反例:** 各种单例乱飞, 直接访问修改单例, 环境, 文件数据等共享资源等等.

- 上层代码对下层代码有绝对控制权(决定权, 选择权):  
    任何权力, 资源的给予都应该 **明确** 由上层给予, 上层代码有绝对的控制权.  
    如果下层提供的功能不符合上层需要, 上层应该有能力用更底层的功能组装起符合自己要求的实现. (强调职责粒度细, 可部分重用)  
    为此需要把每一个可能变化的因素考虑进去. 粒度划分也尽量细, 增加重用的尺度.  
    从而提升模块重用性, 外部使用者的扩展性, 灵活性.

    具体而言, 如果一个类只提供能力, 无主动行为, 那一般认为是安全可控的, 外部可放心使用, 也可灵活自由组合. 这种工具类多多益善.

    但如果一个类包含了主动行为, 或者依赖了环境, 由此形成强耦合, 则上层使用时就会受到相应的限制.  
    这时如果上层需要打破这个限制, 就只能放弃这个类, 使用另外更底层的类的组合替代.  
    这种类应该酌情使用, 做好明确的文档说明, 并和重用性好的纯能力代码隔离开, 相应的代码量尽量少.  
    一般这类代码应该位于最顶层的APP层, 因此可以使用环境或者绑定主动行为.
    或者做为大多数情况默认行为的代码段, 供APP层代码委托使用, 简化上层使用.

    **反例:** 主动保存, 主动决定保存地址等强耦合的行为, 需要和提供能力的类隔离开, 由APP层代码决定控制.

### 明确的输入输出
这条其实对应上面单一职责中的边界明确和控制权划分. 这里只是进一步强调一下在代码清晰度上的影响.

无论函数还是类, 都应该有明确的输入和输出, 不要访问外部环境. 不要有隐式的输入和输出(即环境的输入输出)
函数优先选择只有明确输出的纯函数, 其次是修改输入参数的副作用行为. 不要有访问外部环境的函数. (类中的方法只是隐含self的函数, 也符合函数相关规则)  
而类则尽量只提供能力, 避免预料外的主动行为和内部决定, 由上层代码调用控制.

另外最小化依赖输入可以使输入依赖更明确, 耦合更低.  
反之, 依赖耦合更高, 当前实际依赖也没那么明确, 但相应的索要了更大的权利, 有利于内部修改变更. 这种代码应该慎重考虑使用, 并控制好影响范围.  
(一般频繁变更, 且不需要重用的上层代码考虑, 为了内部可变性和便利性, 牺牲一定的耦合和输入明确度. 例如容器这类万能对象提供的就远大于需要的, 内部可按需扩展).

遵守这条规则可以显著的降低代码复杂度, 改善代码的可读性, 光看接口就能知道是干嘛的, 不用担心有预料外的影响. 也不用花费时间精力成本去阅读实现来掌握理解实现细节.  
(什么是预料外的影响? 比如好好的代码, 某一天环境变了突然出bug了.. 单独测试好好的代码, 集成测试就挂了等等. 即使掌握了实现细节, 也不敢保证和其它代码集成时会不会形成干扰)

### [依赖反转原则](https://en.wikipedia.org/wiki/Dependency_inversion_principle)
模块不直接依赖于底层实现, 而是通过把依赖转换成自定义的抽象输入接口和数据, 由外部选择合适对象实现并进行注入.

**其实这条规则主要是对应职责中的创建权划分, 将创建权和使用权抽象隔离开. 拥有创建权的模块将对创建的对象形成强耦合. ** 
**通过依赖反转, 创建权收敛到了权限最大的最上层, 最上层代码可以使用多态, 实现差异化的模块组装集成工作. 且在依赖变更时, 也只用改集成的一处代码就够了**.  
由此应用了依赖反转注入的模块, 通过把依赖转换为输入, 会更加独立, 自包含. 职责也更加单一, 重用性更好. 上层的组装灵活性也更好.

### [信息隐藏原则](https://en.wikipedia.org/wiki/Information_hiding)
只暴露按自己职责划分, 外界真正需要的最少信息(接口, 类型等), 由此把实现细节, 复杂度, 变化源等封装在内部, 获得更大的内部可变性, 同时降低外部的信息干扰, 方便理解.  

如果后续真有必要, 可以根据需求适当放开限制, 放开限制也比后期重构时发现需要调整接口容易.  
这样也更符合开闭原则(对接口依赖修改关闭, 对内部实现扩展开放)  
实际使用中应该和[接口隔离原则][0]等结合着用.

接合上层代码的绝对控制权来看, 信息隐藏只提供抽象接口.  
上层代码如果不需要更多控制, 可以直接使用. 但如果对实现细节有要求且和目前提供的不一致, 就应该按需组装定制, 替换为自己需要的.

两者关注点不一样, 信息隐藏是基于自身职责和可变性的考虑. 上层代码的控制权是基于上层代码实现选择权和成本的考虑.

最终还是依据模块的职责划分, 定位, 可变性等, 来决定是最小输出(隔离实现, 保留内部可变性, 降低耦合), 还是暴露细节(增加上层代码灵活性, 增加耦合).

### [响应式和数据流](https://en.wikipedia.org/wiki/Reactive_programming)
通过[RxSwift][1]等函数式数据流框架, 实现细粒度的数据和事件流的变换组合与绑定.  
由此描述程序间的相互关系, 使得数据变化或事件发生时, 程序能自动响应变化.  

和原来的命令式编程相比, 主要是描述式直接建立相互间的约束关系, 可读性更高. 而函数式的数据源变换组合, 重用粒度更细. 整体代码会更简洁灵活  
相应的代价是思维的转变, 资源开销, Debug堆栈不那么好看等.

[0]: https://en.wikipedia.org/wiki/Interface_segregation_principle
[1]: https://github.com/ReactiveX/RxSwift


### 依赖反转 Dependence Inversion Principle

![](https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/20200402142514.png)

在传统的应用架构中，低层次的组件设计用于被高层次的组件使用，这一点提供了逐步的构建一个复杂系统的可能。在这种结构下，高层次的组件直接依赖于低层次的组件去实现一些任务。**这种对于低层次组件的依赖限制了高层次组件被重用的可行性**。

依赖反转原则的目的是把高层次组件从对低层次组件的依赖中解耦出来，这样使得重用不同层级的组件实现变得可能。把高层组件和低层组件划分到不同的包/库（在这些包/库中拥有定义了高层组件所必须的行为和服务的接口，并且存在高层组件的包）中的方式促进了这种解耦。由于低层组件是对高层组件接口的具体实现，因此低层组件包的编译是依赖于高层组件的，这颠倒了传统的依赖关系。众多的设计模式，比如插件，服务定位器或者依赖反转，则被用来在运行时把指定的低层组件实现提供给高层组件。


采用依赖倒置原则给多人并行开发带来了极大的便利，比如上例中，原本Mother类与Book类直接耦合时，Mother类必须等Book类编码完成后才可以进行编码，因为Mother类依赖于Book类。修改后的程序则可以同时开工，互不影响，因为Mother与Book类一点关系也没有。参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。

 传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递，相信用过Spring框架的，对依赖的传递方式一定不会陌生。

在实际编程中，我们一般需要做到如下3点：


* 低层模块尽量都要有抽象类或接口，或者两者都有。
* 变量的声明类型尽量是抽象类或接口。
* 使用继承时遵循里氏替换原则。
依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。

![](https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/20200402143746.png)


### 控制反转 （IoC）

控制反转 IoC 是 Inversion of Control的缩写，意思就是对于控制权的反转，对么控制权是什么控制权呢？

Person 自己掌控着内部 mDriveable 的实例化。
现在，我们可以更改一种方式。将 mDriveable 的实例化移到 Person 外面。

```swift
public class Person {

    private Driveable mDriveable;

    public Person(Driveable driveable) {

        this.mDriveable = driveable;
    }

    public void chumen() {
        System.out.println("出门了");

        mDriveable.drive();
    }
}
```

就这样无论出行方式怎么变化，Person 这个类都不需要更改代码了。

[轻松学，浅析依赖倒置（DIP）、控制反转(IOC)和依赖注入(DI)_移动开发_frank 的专栏-CSDN博客](https://blog.csdn.net/briblue/article/details/75093382)

#### 依赖注入（Dependency injection）

为了不因为依赖实现的变动而去修改 Person，也就是说以可能在 Driveable 实现类的改变下不改动 Person 这个类的代码，尽可能减少两者之间的耦合。我们需要采用上一节介绍的 IoC 模式来进行改写代码。

这个需要我们移交出对于依赖实例化的控制权，那么依赖怎么办？Person 无法实例化依赖了，它就需要在外部（IoC 容器）赋值给它，这个赋值的动作有个专门的术语叫做注入（injection），需要注意的是在 IoC 概念中，这个注入依赖的地方被称为 IoC 容器，但在依赖注入概念中，一般被称为注射器 （injector)。


**表达通俗一点就是：我不想自己实例化依赖，你（injector）创建它们，然后在合适的时候注入给我吧。**


再比如顾客去餐厅需要碗筷，但是顾客不需要自己带碗筷去，所以，在点菜的时候和服务员说，你给我一副碗筷吧。在这个场景中如果按照正常的编程方式，碗筷本身是顾客的依赖，但是应用 IoC 模式之后 ，碗筷是服务员提供（注入）给顾客的，顾客不用关心吃饭的时候用什么碗筷，因为吃不同的菜品，可能餐具不同，吃牛排用刀叉，喝汤用调羹，虽然顾客就餐时需要餐具，但是餐具的配置应该交给餐厅的工作人员。

实现依赖注入有 3 种方式：
1. 构造函数中注入
2. setter 方式注入
3. 接口注入

### 总结

* 依赖倒置是面向对象开发领域中的软件设计原则，它倡导上层模块不依赖于底层模块，抽象不依赖细节。
* 依赖反转是遵守依赖倒置这个原则而提出来的一种设计模式，它引入了 IoC 容器的概念。
* 依赖注入是为了实现依赖反转的一种手段之一。
* 它们的本质是为了代码更加的“高内聚,低耦合”。


# Ref

* [](https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99)