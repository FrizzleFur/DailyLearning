# iOS 组件化开发项目框架设计

> iOS 组件化开发项目框架设计，结合 MVVM 设计模式 + RAC 数据绑定 + Pod 组件管理， 实现一套实战性的iOS组件化框架

[iOS 组件化方案探索 | WeRead团队博客](https://wereadteam.github.io/2016/03/19/iOS-Component/)
[iOS组件化实践(一)：简介 - 简书](https://www.jianshu.com/p/568e875abd48)
[iOS组件化实践(三)：实施 - 简书](https://www.jianshu.com/p/0a7f3c0b4194)

## SOLID原则

对于iOS这种面向对象编程的开发模式来说，我们应该遵循以下五个原则，即SOLID原则。

* 单一功能原则: 对象功能要单一，不要在一个对象里添加很多功能。
* 开闭原则: 扩展是开放的，修改是封闭的。
* 里氏替换原则: 子类对象是可以替代基类对象的。
* 接口隔离原则: 接口的用途要单一，不要在一个接口上根据不同入参实现多个功能。
* 依赖反转原则: 方法应该依赖抽象，不要依赖实例。iOS开发就是高层业务方法依赖于协议。
同时，遵守这五个原则是开发出容易维护和扩展的架构的基础。

### 组件化开发团队

* 首先，**需要一个专门的基建团队**，负责业务无关的基础功能组件和业务相关通用业务组件开发。
* 然后，**每个业务都由一个专门的团队来负责开发**。业务可以按照功能耦合度来划分，耦合度高的业务可以划分成单独的业务团队。
* 基建团队人员应该是流动的，从业务团队里来，再回到业务团队中去。这么设计是因为业务团队和基建团队的边界不应该非常明显，否则就会出现基建团队埋头苦干，结果可能是做得过多、做得不够，或着功能不好用的问题，造成严重的资源浪费。

## 组件化架构

* 协议式

协议式架构设计主要采用的是协议式编程的思路: **在编译层面使用协议定义规范，实现可在不同地方，从而达到分布管理和维护组件的目的**。这种方式也遵循了依赖反转原则，是一种很好的面向对象编程的实践。

但是，这个方案的缺点也很明显，主要体现在以下两个方面:

1. 由于协议式编程缺少统一调度层，导致难于集中管理，特别是项目规模变大、团队变多的情况下，架构管控就会显得越来越重要。
2. 协议式编程接口定义模式过于规范，从而使得架构的灵活性不够高。当需要引入一个新的设计模式来开发时，我们就会发现很难融入到当前架构中，缺乏架构的统一性。
虽然协议式架构有这两方面的局限性，但由于其简单易用的特点依然被很多公司采用。

* 中间者

另一种常用的架构形式是中间者架构。
* 它采用中间者统一管理的方式，来控制App的整个生命周期中组件间的调用关系。
* 同时，iOS对于组件接口的设计也需要保持一致性， 方便中间者统一调用。

中间者架构如下图所示:

![](https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/20190319095520.png)


* 可以看到，拆分的组件都会依赖于中间者，但是组间之间就不存在相互依赖的关系了。由于其他组件都会依赖于这个中间者，相互间的通信都会通过中间者统一调度，所以组件间的通信也就更容易管理了。在中间者上也能够轻松添加新的设计模式，从而使得架构更容易扩展。

* 在我看来，好的架构一定是健壮的、灵活的。中间者架构的易管控带来的架构更稳固，易扩展带来的灵活性，所以我认为中间者这种架构设计模式是非常值得推荐的。casatwy 以前设计了一个[CTMediator](https://github.com/casatwy/CTMediator)就是按照中间者架构思路设计的。你可以在GitHub.上看到它的内容。

### 大厂组件化参考

* 淘宝

* 淘宝架构的核心思想是一切皆组件，将工程中所有代码都抽象为组件。

![](https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/20190319181223.png)

* 淘宝架构主要分为四层，最上层是组件Bundle(业务组件)，依次往下是容器(核心层)，中间件Bundle(功能封装)，基础库Bundle(底层库)。容器层为整个架构的核心，负责组件间的调度和消息派发。

* 总线设计：URL路由+服务+消息。统一所有组件的通信标准，各个业务间通过总线进行通信。
![](https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/20190319181345.png)

URL总线
通过URL总线对三端进行了统一，一个URL可以调起iOS、Android、前端三个平台，产品运营和服务器只需要下发一套URL即可调用对应的组件。
URL路由可以发起请求也可以接受返回值，和MGJRouter差不多。URL路由请求可以被解析就直接拿来使用，如果不能被解析就跳转H5页面。这样就完成了一个对不存在组件调用的兼容，使用户手中比较老的版本依然可以显示新的组件。
服务提供一些公共服务，由服务方组件负责实现，通过Protocol进行调用。
消息总线
应用通过消息总线进行事件的中心分发，类似于iOS的通知机制。例如客户端前后台切换，则可以通过消息总线分发到接收消息的组件。因为通过URLRouter只是一对一的进行消息派发和调度，如果多次注册同一个URL，则会被覆盖掉。
Bundle App

![](https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/20190319181441.png)


## 依赖注入

传统图层模式

在传统的应用程序体系结构中，较低级别的组件（例如，实用程序层）被设计为由更高级别的组件（例如，策略层）使用，这使得能够构建越来越复杂的系统。在此组合中，更高级别的组件直接依赖于较低级别的组件来完成某些任务。对较低级别组件的这种依赖性限制了较高级别组件的重用机会。[1]

![](https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/20190714165253.png)

依赖倒置模式

通过添加抽象层，高层和低层都可以从上到下减少传统的依赖关系。然而，“反转”概念并不意味着较低级别的层依赖于较高级别的层。两个层都应该依赖于绘制更高层所需行为的抽象。

![](https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/20190714165311.png)

直接实现将策略类与服务抽象类打包在一个库中。在此实现中，高级组件和低级组件被分布到单独的包/库中，其中定义高级组件所需的行为/服务的接口由高级组件的库拥有并存在于高级组件的库中。低级组件对高级组件接口的实现要求低级组件包依赖于高级组件进行编译，从而颠倒传统的依赖关系。

![](https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/20190714165530.png)

图1和图2示出了具有相同功能的代码，但是在图2中，已经使用接口来反转依赖性。可以选择依赖的方向以最大化策略代码重用，并消除循环依赖性。

在此版本的DIP中，较低层组件对较高层中的接口/摘要的依赖性使得较低层组件的重新利用变得困难。相反，这种实现将传统依赖从“自上而下”反转为“从底部到顶部”。

更灵活的解决方案将抽象组件提取到一组独立的包/库中：

![](https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/20190714165555.png)


## 静态库和动态库

![](https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/20190203203917.png)

## iOS从零到一搭建组件化项目架构

> 随着公司业务需求的不断迭代发展，工程的代码量和业务逻辑也越来越多，原始的开发模式和架构已经无法满足我们的业务发展速度了，这时我们就需要将原始项目进行一次重构大手术了。这时我们应该很清晰这次手术的动刀口在哪，就是之前的高度耦合的业务组件和功能组件，手术的目的就是将这些耦合拆分成互相独立的各个组件。

## 工程效果预览
![image](http://upload-images.jianshu.io/upload_images/6342050-a3211580aef1c283.jpg?imageMogr2/auto-orient/strip)

[掘金专栏文章详解](https://juejin.im/post/5ba3cc0df265da0aac6fdaa0)

### 下面我们围绕这几个问题来展开讲解

* 为什么要用组件化，它给我们带来哪些优势
* 各个组件该如何进行拆分，拆分的颗粒度该如何控制
* 如何从零到一搭建组件化架构项目

## 为什么要用组件化
我们先来张图看看在没有使用组件化前，我们各个模块间的依赖关系

![image](http://upload-images.jianshu.io/upload_images/6342050-872d698987796c0b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

从上面这种各个业务组件的依赖关系来看，他们是互相依赖的，业务组件和业务组件间产生了严重的耦合关系，这样一来对我们工程的扩展性就会大大的降低，维护成本就会变高。

举个例子：假设某天产品经理说，咱们公司的业务发展的太好了，咱们的营销模块需要独立出来成一个单独的应用，以便于咱们可以添加更多高效的营销手段。这时我们就傻眼了，需要独立出一个app出来，这可怎么搞啊，营销模块的代码和其他的很多业务代码耦合在一起了，现在要独立出来，那就只能重新写一个营销应用了，之前的代码剥离不干净了。

从上面我们列举的一个简单的例子可以体会到：在项目没有做到真真意义上的组件化之前，各个业务模块和业务模块间的高度耦合，功能组件和功能组件间的高度耦合对未来公司的业务扩展来说，成本很高，不能做到同样业务逻辑的代码的高度复用，这样对我们开发来说也是效率的降低。

好了，有的同学可能会说，既然上面各个模块间耦合这么高，那我就来将这些耦合解耦，于是，可能会出现下面这张图的模块间的关系。

![image](http://upload-images.jianshu.io/upload_images/6342050-3ca9d9a5293c60fd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

从下面这张图来看，我们发现，现在确实能做到各个业务模块间完全的解耦了，他们不再互相依赖了，同时我们引入了一个中间调度者的一个角色，现在是各个业务模块和这个中间调度者角色产出了严重的依赖。我们思考下发现，我们的各个业务模块依赖这个中间调度者，这个是完全正常的，因为他们需要这个调度者来做统一的事件分发工作，但是这个调度者却又依赖了每个业务模块，这层依赖是有必要的吗？我们回头想想真正的组件化开发是完全的去依赖化，这个依赖是完全没有必要的。例如：假设我们现在有一个新的B APP需要开发，这时我们也需要用到这个中间调度者组件，但是我们不能直接拿过来用，因为它又依赖了很多A App的业务组件。因此，我们的组件化架构设计又需要一次升级变更了，升级成如下图所示的模型。

![image](http://upload-images.jianshu.io/upload_images/6342050-f2f7278c12bbe7e9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

从上面的这张图，我们可以看出，各个业务模块间只会依赖中间调度者，并且中间调度者不对各个模块产生任何的依赖。

好了，从上面的三张图之间的对比，我们就可以很好的理解为什么我们的工程急需要实现组件化架构开发了，以及各自的优劣势。

## 各个组件该如何进行拆分
> 关于组件该如何拆分，这个没有一个完整的标准，因为每个公司的业务场景不一样，对应衍生出来的各个业务模块也就不一样，所以业务组件间的拆分，这个根据自己公司的业务模块来进行合理的划分即可。这里我们来说下整个工程的组件大致的划分方向

1. 项目主工程：当我们工程完全使用组件化架构进行开发后，我们会惊奇的发现我们的主工程就成了一个空壳子工程。因为所有的主工程呈现出来的内容都被拆分成了各个独立的业务组件了，包括各个工具组件也是各自互相独立的。这样我们发现开发一个完整的APP就像是搭建乐高积木一样，各个部件都有，任我们随意的组合搭建，这样是不是感觉很爽。
2. 业务组件：业务组件就是我们上面示例图所示的各个独立的产品业务功能模块，我们将其封装成独立的组件。例如示例Demo中的电子发票业务组件，业务组件A，业务组件B。我们通过组装各个独立的业务组件来搭建一个完整的APP项目。
3. 基础工具类组件：基础工具类是各个互相独立，没有任何依赖的工具组件。它们和其它的工具组件、业务组件等没有任何依赖关系。这类组件例如有：对数组，字典进行异常保护的Safe组件，对数组功能进行扩展Array组件，对字符串进行加密处理的加密组件等等。
4. 中间件组件：这个组件比较特殊，这个是我们为了实现组件化开发而衍生出来的一个组件，上面示例图中的中间调度者就是一个功能独立的中间件组件。
5. 基础UI组件：视图组件就比较常见了，例如我们封装的导航栏组件，Modal弹框组件，PickerView组件等。
6. 业务工具组件：这类组件是为各个业务组件提供基础功能的组件。这类组件可能会依赖到其他的组件。例如：网络请求组件，图片缓存组件，jspatch组件等等

**至于组件的拆分颗粒度，这个着实不好去断定，因人而异，不同的需求功能复杂度拆分出来的组件大小也不尽相同**

## 如何从零到一搭建组件化架构

> 在讲如何从零到一来实现一个组件化架构项目前，我们需要熟练掌握使用pod来制作组件库。下面我们就围绕提供的组件化示例项目来展开讲解。

**首先，我们来看示例Demo中包含哪些业务组件(如下图所示：)：**

![image](http://upload-images.jianshu.io/upload_images/6342050-f997b06e8b0e4aa5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

示例Demo中，我提供了三个业务组件来作为演示效果，其中业务模块A和业务模块B是临时业务模块组件，电子发票业务组件时真实的企业需求功能组件。

**我们再来看下示例Demo中都提供了哪些工具组件(如下图所示)**

> **注意了：这里提供的6个工具组件也都是作者已经封装好的功能组件，大家也可以直接 install 安装使用的哦。**

![image](http://upload-images.jianshu.io/upload_images/6342050-3118e206c17518f4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 详细操作步骤

**第一步：**

我们先创建一个空的iOS工程项目:MainProject，这个空项目作为我们的主工程项目，就是上面所说的壳子工程项目，然后初始化pod，这里不清楚pod的使用的小伙伴们请自行查阅资料。

**第二步：**

我们创建一个空工程项目:ModuleA，这个ModuleA 项目作为我们的业务A组件。然后我们初始化pod，初始化podspec文件。

**第三步：**

我们创建一个空工程项目:ModuleB，这个ModuleB 项目作为我们的业务B组件。然后我们初始化pod，初始化podspec文件。

**第四步：**

我们创建一个空工程项目:ComponentMiddleware，这个项目就是我们上面所说的中间调度者。然后我们初始化pod，初始化podspec文件。

**第五步：**

我们创建一个空工程项目: ModuleACategory，这个工程是对应业务组件A的一个分类工程。然后我们初始化pod，初始化podspec文件。

**第六步：**

我们创建一个空工程项目: ModuleBCategory，这个工程是对应业务组件B的一个分类工程。然后我们初始化pod，初始化podspec文件。


好了，上面的主工程和两个业务组件工程，以及两个组件分类工程都已创建完毕，下面我们来讲解他们各个之间如何工作的。我就从主工程加载业务组件开始往下捋，顺藤摸瓜式的引出每个工程的用意。

**第七步：**

我们在主工程MainProject的Podfile中引入我们的业务组件B工程ModuleB，以及引入我们的ModuleB的分类工程：ModuleBCategory。然后我们pod install。这时已将这两个组件库引入到我们的主工程中了。

示例代码如下：

```
# Uncomment the next line to define a global platform for your project
platform :ios, '8.0'

source 'https://github.com/CocoaPods/Specs.git'
source 'https://github.com/guangqiang-liu/GQSpec.git'

target 'GQComponentDemo' do
  
  pod 'ModuleB'
  pod 'ModuleBCategory'
end
```

然后我们在主工程中添加一个按钮事件，这个事件是点击 push 到业务组件B的 页面。

示例代码如下：

```
#import <ModuleBCategory/ComponentScheduler+ModuleB.h>

- (void)moduleB {
    UIViewController *VC = [[ComponentScheduler sharedInstance] ModuleB_viewControllerWithCallback:^(NSString *result) {
        NSLog(@"resultB: --- %@", result);
    }];
    [self.navigationController pushViewController:VC animated:YES];
}
```

**第八步：**


上面第七步中，我们用到了ModuleBCategory 这个分类工程。这个工程我们只对外暴露了两个文件。这两文件是上面的中间调度者的分类，也就是说是中间件的分类。我们先来看下这个分类文件的.h 和.m 实现。

**.h**

```
#import "ComponentScheduler.h"

@interface ComponentScheduler (ModuleB)

- (UIViewController *)ModuleB_viewControllerWithCallback:(void(^)(NSString *result))callback;

@end
```

**.m**

```
#import "ComponentScheduler+ModuleB.h"

@implementation ComponentScheduler (ModuleB)

- (UIViewController *)ModuleB_viewControllerWithCallback:(void(^)(NSString *result))callback {
    NSMutableDictionary *params = [[NSMutableDictionary alloc] init];
    params[@"callback"] = callback;
    return [self performTarget:@"ModuleB" action:@"viewController" params:params shouldCacheTarget:NO];
}
@end

```

我们发现这个分类实现非常的简单，就是对外暴露一个函数，然后执行`[self performTarget:@"ModuleB" action:@"viewController" params:params shouldCacheTarget:NO];` ，并将执行的返回值返回出去。

这个分类的作用你可以理解为我们提前约定好Target的名字和Action的名字，因为这两个名字中间件组件中会用到。

上面的`performTarget:action:params:shouldCacheTarget` 函数是中间件提供的函数。因为ModuleBCategory 是 ComponentScheduler(中间件)的分类文件，所以可以调用到这个函数啦。

在ModuleBCategory 工程中需要引用到了中间件工程所以我们需要在ModuleBCategory 的Podfile文件中引用 中间件组件

示例代码如下：

```
# Uncomment the next line to define a global platform for your project
platform :ios, '8.0'

source 'https://github.com/CocoaPods/Specs.git'
source 'https://github.com/guangqiang-liu/GQSpec.git'

target 'ModuleB-Category' do
  # Uncomment the next line if you're using Swift or would like to use dynamic frameworks
  # use_frameworks!

  # Pods for ModuleB-Category
  
  pod 'ComponentScheduler'

end
```

**第九步：**

因为上面第八步中引用到中间件工程，这里我们就来看下中间件工程到底做了什么工作。还记得上面第八步中，我们调用了一个中间件提供的函数：`performTarget:action:params:shouldCacheTarget` 吧，这个是中间件核心函数。

核心函数代码块如下：

![image](http://upload-images.jianshu.io/upload_images/6342050-6ff4b1198191afe2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

还记得上面第八步中，我们调用这个函数传递的参数吧，我们在把调用代码拿过来看下

`[self performTarget:@"ModuleB" action:@"viewController" params:params shouldCacheTarget:NO];`

我们可以看到 `TargetName ` 是我们传递的 `ModuleB`，`action`是我们传递的`viewController`，然后我们将 这两个参数传给了下面的函数：

`[self safePerformAction:action target:target params:params];`

我们来看下这两个参数的值具体是什么：

![image](http://upload-images.jianshu.io/upload_images/6342050-5fc6fb258294b611.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这个函数最终调用到苹果官方提供的函数：`[target performSelector:action withObject:params];`

看到 `performSelector: withObject: ` 大家应该就比较熟悉了，iOS的消息传递机制。

```
[Target_ModuleB performSelector:Action_viewController withObject:params];
```

上面这行伪代码意思是: `Target_ModuleB`这个类 调用它的 `Action_viewController:` 方法，然后传递的参数为 `params `。

细心的小伙伴们就会发现，我们没有看到过哪里有这个`Target_ModuleB ` 类啊，更没有看到`Target_ModuleB ` 调用它的 `Action_viewController:` 方法啊。

是的，这个`Target_ModuleB `类和类的`Action_viewController `方法就在第十步中讲解到。

**第十步：**

终于到了最后一步了，写的好艰辛，嗯，小伙们不要捉急，快了，快讲完了

细心的小伙们发现，我们上面讲的9步中，好像都没有提业务组件B的东西。是的，业务组件B除了提供组件B的业务功能外，业务组件B还需要为我们提供一个Target文件。

我们先来看下业务组件B的业务代码：

示例代码如下：

```
#import "ModuleBViewController.h"
#import "PageBViewController.h"

@interface ModuleBViewController ()

@end

@implementation ModuleBViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view.
    self.title = @"我是模块B业务组件";
    
    self.view.backgroundColor = [UIColor whiteColor];
    
    UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom];
    btn.frame = CGRectMake(0, 0, 300, 100);
    btn.backgroundColor = [UIColor greenColor];
    btn.center = self.view.center;
    [btn setTitle:@"模块B业务功能组件" forState: UIControlStateNormal];
    [btn addTarget:self action:@selector(push) forControlEvents:UIControlEventTouchUpInside];
    [self.view addSubview:btn];
}

- (void)push {
    PageBViewController *VC = [[PageBViewController alloc] init];
    [self.navigationController pushViewController:VC animated:YES];
}

- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}
```

我们发现，业务组件B的业务代码也很简单，就是做一个push 跳转操作，从PageA 控制器跳转到 PageB 控制器。 这个没有什么好讲的

我们再来看上面提到的target文件

示例代码如下：

**.h**

```
#import <Foundation/Foundation.h>
#import <UIKit/UIKit.h>

@interface Target_ModuleB : NSObject

- (UIViewController *)Action_viewController:(NSDictionary *)params;

@end
```

**.m**

```
#import "Target_ModuleB.h"
#import "ModuleBViewController.h"

@implementation Target_ModuleB

- (UIViewController *)Action_viewController:(NSDictionary *)params {
    ModuleBViewController *VC = [[ModuleBViewController alloc] init];
    return VC;
}

@end

```

从上面的实现文件中，我们可以看到，Target文件的作用也很简单，就是为我们提供导航跳转的目标控制器实例对象。这里的目标控制器实例就是业务组件B的`ModuleBViewController` 实例。

细心的小伙伴们发现，咦！我们在第九步中打印出来的`target` 和 `action` 不就正是Target文件的`Target_ModuleB ` 和 `Action_viewController:` 。

上面我们只是串讲了业务组件B的一系列流程，业务组件A的用法和业务组件B的用法一样，如果后面再有业务组件C，D，都是一样的道理，就不再一一讲解了。

好了，现在小伙伴们应该看懂了这一连串的工作流程了吧，如果还没有看懂，那就重新看一遍咯。作者建议直接运行提供的示例Demo项目进行调试，这样便于理解各个组件之间的关系。 

**最后，我们再来看张组件化完整的架构图：**

![image](http://upload-images.jianshu.io/upload_images/6342050-6db65dfbc259432d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 组件集成


![](https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/20190319153955.png)

* 每个组件都是一个单独的工程，在组件开发完成后上传到git仓库。主工程通过Cocoapods集成各个组件，集成和更新组件时只需要pod update即可。这样就是把每个组件当做第三方来管理，管理起来非常方便。
* Cocoapods可以控制每个组件的版本，例如在主项目中回滚某个组件到特定版本，就可以通过修改podfile文件实现。选择Cocoapods主要因为其本身功能很强大，可以很方便的集成整个项目，也有利于代码的复用。通过这种集成方式，可以很好的避免在传统项目中代码冲突的问题。


### 组件化优点

* 组件化开发可以很好的提升代码复用性，组件可以直接拿到其他项目中使用，这个优点在下面淘宝架构中会着重讲一下。
* 对于调试工作，可以放在每个组件中完成。单独的业务组件可以直接提交给测试使用，这样测试起来也比较方便。最后组件开发完成并测试通过后，再将所有组件更新到主项目，提交给测试进行集成测试即可。
* 通过这样的组件划分，组件的开发进度不会受其他业务的影响，可以多个组件并行开发。组件间的通信都交给中间件来进行，需要通信的类只需要接触中间件，而中间件不需要耦合其他组件，这就实现了组件间的解耦。中间件负责处理所有组件之间的调度，在所有组件之间起到控制核心的作用。
* 组件化框架清晰的划分了不同模块，从整体架构上来约束开发人员进行组件化开发，实现了组件间的物理隔离。组件化架构在各个模块之间天然形成了一道屏障，避免某个开发人员偷懒直接引用头文件，产生组件间的耦合，破坏整体架构。
* 使用组件化架构进行开发时，因为每个人都负责自己的组件，代码提交也只提交自己负责模块的仓库，所以代码冲突的问题会变得很少。
* 假设以后某个业务发生大的改变，需要对相关代码进行重构，可以在单个组件内进行重构。组件化架构降低了重构的风险，保证了代码的健壮性。


## 参考组件库

[wangshiyu13/Lothar: 基于CTMediator的组件化中间件](https://github.com/wangshiyu13/Lothar)


## 总结

> 上面我们讲解的只是简单的项目组件化架构的基础框架搭建，但是在真正的企业开发中，我们只搭建这样一个简单项目框架结构还远远不能满足需求的开发，我们还需要在项目框架中添枝加叶来满足现有需求。在上面提供的示例Demo中，我将电子发票业务组件独立成一个完整的工程，并结合了当下比较流行的MVVM设计模式和RAC数据绑定框架来实现电子发票模块的功能开发。如果有小伙们对 MVVM + RAC 实战开发感兴趣的，可以单独 install 电子发票工程查看，工程地址:[iOS-MVVM-RAC](https://github.com/guangqiang-liu/iOS-MVVM-RAC)



组件化开源项目 [iOS-Component-Pro](https://github.com/guangqiang-liu/iOS-Component-Demo)

[掘金专栏文章详解](https://juejin.im/post/5ba3cc0df265da0aac6fdaa0)


### 1.为什么要做模块化？


我们都知道最基本的代码设计原则：“Don’t repeat yourself!”，每一个工程都会有自己的架构，即使你是刚入门的开发者，写几天代码也会发现要把一些常用到的重复代码单独拿出来放在一个叫common的地方，实现代码复用。这样看来每个开发者其实都或多或少的做过架构方面的事情，每个团队至少有1~2个人在做这样的事情。


### 2. 模块设计原则

越底层的模块，应该越稳定，越抽象，越具有高复用度。

这一点，目测大家应该比较认同，越是底层的SDK，就应该越稳定，稳定的最直观表现就是API很久都不用变化，所有的变化因子不要暴露出来，避免传递给依赖它的模块。但是要做到设计一套API很久都不用改变，那么就需要设计的时候能越抽象, 即需要我们抽象总结的能力。

稳定性 还有一个特点就是会传递，比如 B 模块依赖了 A 模块，如果 B 模块很稳定，但是 A 模块不稳定，那么B模块也会变的不稳定了，因此下一个原则：

不要让稳定的模块依赖不稳定的模块， 减少依赖

既然上面说最好不要依赖，但是我发现我的 B 模块的确依赖了 A 模块里面不可或缺的代码怎么办？ 假设依赖的代码段为 x , 现在来看x的特性, 如果X是一个可能高复用的代码段，那么无妨把x从 A 模块里面拿出来，单做成一个模块 X, 那么 B 模块依赖 X 模块就好了；灵一种情况，x是一个方法或函数，而且不太适合单做成一个模块，所以那就在B模块里面拷贝一份 x 代码就ok了，因为这样可以保证模块的 稳定性 和 自完备性.

如果上面两种方法都不太合适，我们会在后面解耦里面讲到如何解耦

提升模块的复用度，自完备性有时候要优于代码复用

什么是自完备性，就是尽可能的依赖少的模块来达到代码可复用。

举个例子，我有个模块 Utils 里面放了大量的category工具方法等，在日常UI产品开发中，依赖这个Utils会很方便，但是我现在要写一个比较基础的模块，应该就要求复用度更高一些，这个时候需要用到Utils里面的几个方法，那这个时候还适合直接依赖Utils吗，当然不合适了，这与我们上面的设计原则相悖了啊，因此我们这时候为了这个模块的自完备性，就可以重新实现下这几个方法，而不是依赖Utils模块

每个模块只做好一件事情，不要让Common出现

模块化结构是让工程结构更清晰，每个模块都只做一件事情，都有自己的一个命名，这样这个模块才能良性发展， 但是这个名字千万不要再叫Common了，试想下你有没有做过这样的事情：“哎呀，这块代码放哪都不太合适，放Common吧”， 日久以后，这个Common就变成了毒瘤，大家都依赖它，还一堆不相关的代码，这个Common模块就是我们设计原则第一点的反面教材： “非常不稳定，大量依赖，全是耦合，整个模块无法复用到其他app”, 所以删掉工程里面的Common吧，再遇到不知道放哪的代码，就要好好思考模块的设计，再不行如果具有可复用性就单建一个模块吧，为什么不可以呢？

按照你架构的层数从上到下依赖，不要出现下层模块依赖上层模块的现象

业务模块之间也尽量不要耦合


## 参考文献

> 本篇文章主要借鉴了casatwy的CTMediator思想重新实践了一遍，下面也有蘑菇街的MGJRouter 和 阿里的 BeeHive 供大家学习参考。

* https://casatwy.com/modulization_in_action.html
* https://github.com/casatwy/CTMediator
* https://github.com/alibaba/BeeHive/blob/master/README-CN.md
* http://limboy.me/tech/2016/03/10/mgj-components.html
* https://github.com/meili/MGJRouter

## 更多文章
* 作者React Native开源项目OneM地址(按照企业开发标准搭建框架完成开发的)：**[https://github.com/guangqiang-liu/OneM](https://github.com/guangqiang-liu/OneM)**：欢迎小伙伴们 **star**
* 作者简书主页：包含60多篇RN开发相关的技术文章[http://www.jianshu.com/u/023338566ca5](http://www.jianshu.com/u/023338566ca5) 欢迎小伙伴们：**多多关注**，**多多点赞**
* React Native QQ技术交流群(600+ RN工程师)：**620792950** 欢迎小伙伴进群交流学习
* iOS QQ技术交流群：**678441305** 欢迎小伙伴进群交流学习

## 参考

1. [iOS-Component-Pro/README.md at master · guangqiang-liu/iOS-Component-Pro](https://github.com/guangqiang-liu/iOS-Component-Pro/blob/master/README.md)
2. [模块化与解耦 - 刘坤的技术博客](https://blog.cnbluebox.com/blog/2015/11/28/module-and-decoupling/)