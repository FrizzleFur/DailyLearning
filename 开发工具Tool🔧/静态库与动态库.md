# iOS中的静态库与动态库，区别、制作和使用

如果我们有些功能要给别人用，但是又不想公开代码实现，比如高德地图、第三方登录分享等等，这时候我们就要打包成库了。库分静态库和动态库两种：

> 静态库：以`.a` 和 `.framework`为文件后缀名。
> 动态库：以`.tbd`(之前叫`.dylib`) 和 `.framework` 为文件后缀名。

##### 静态库与动态库的区别

> 静态库：链接时会被完整的复制到可执行文件中，被多次使用就有多份拷贝。
> 动态库：链接时不复制，程序运行时由系统动态加载到内存，系统只加载一次，多个程序共用（如系统的`UIKit.framework`等），节省内存。
## 静态库和动态库的区别

**　　　不同点**：

*   静态库在链接时，会被完整的复制到可执行文件中，如果多个App都使用了同一个静态库，那么每个App都会拷贝一份，缺点是浪费内存。类似于定义一个基本变量，使用该基本变量是是新复制了一份数据，而不是原来定义的；
*   动态库不会复制，只有一份，程序运行时动态加载到内存中，系统只会加载一次，多个程序共用一份，节约了内存。类似于使用变量的内存地址一样，使用的是同一个变量；

    **共同点：**
*   静态库和动态库都是闭源库，只能拿来满足某个功能的使用，不会暴露内部具体的代码信息

### 静态库的处理方式

*   对于一个静态库而言，其实已经是编译好的了,类似一个 .o 的集合 这里并没有连接。在 build 的过程中只会参与链接的过程，而这个链接的过程简单的讲就是合并，并且链接器只会将静态库中被使用的部分合并到可执行文件中去。相比较于动态库，静态库的处理起来要简单的多，具体如下图：

          [![静态库链接过程](https://github.com/Damonvvong/iOSDevNotes/raw/master/images/framework2-jtb.jpg)](https://github.com/Damonvvong/iOSDevNotes/blob/master/images/framework2-jtb.jpg)

*   链接器会将所有**.o**用到的 global symbol 和 unresolved symbol 放入一个临时表，而且是 global symbol 是不能重复的。

*   对于静态库的 .o , 连接器会将没有任何 symbol 在 unresolved symbol table 的给忽略。

*   unresolved symbol 类似 `extern int test();` --- **.h **的 声明?

*   global symbol 类似 `void test() { print("test")}` --  .m 的 实现?

*   最后，链接器会用函数的实际地址来代替函数引用。

### [](https://github.com/Damonvvong/iOSDevNotes/blob/master/Notes/framework2.md#%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F)动态库的处理方式

*   首先，对于动态库而言其实分 动态链接库 和 动态加载库 两种的，这两个最本质的区别还是加载时间。
    *   动态链接库：在没有被加载到内存的前提下，当可执行文件被加载，动态库也随着被加载到内存中。在 Linked Framework and Libraries 设置的一些 share libraries。【随着程序启动而启动】
    *   动态加载库：当需要的时候再使用 dlopen 等通过代码或者命令的方式来加载。【在程序启动之后】
*   但是不论是哪种动态库，相比较与静态库，动态库处理起来要棘手的多。由于动态库是动态的，所以你事先不知道某个函数的具体地址。因此动态链接器在链接函数的时候需要做大量的工作。

> 因为动态库在链接函数需要做大量的工作，而静态库已经实现处理好了。所以单纯的在所有都没有加载的情况下，静态库的加载速度会更快一点。而在 [iOS 开发中的『库』(一)](https://github.com/Damonvvong/iOSDevNotes/blob/master/Notes/framework.md) 提到的有所不妥，正确应该是，虽然动态库更加耗时，但是对于在加载过的share libraries不需要再加载的这个前提下，使用动态库可以节省一些启动时间。

*   而实现这个动态链接是使用了 Procedure Linkage Table (PLT)。首先这个 PLT 列出了程序中每一个函数的调用，当程序开始运行，如果动态库被加载到内存中，PLT 会去寻找动态的地址并记录下来，如果每个函数都被调用过的话，下一次调用就可以通过 PLT 直接跳转了，但是和静态库还是有点区别的是，每一个函数的调用还是需要通过一张 PLT。这也正是 sunny 所说的所有静态链接做的事情都搬到运行时来做了，会导致更慢 的原因。


## 参考

1. [iOS中的静态库与动态库，区别、制作和使用 - 简书](https://www.jianshu.com/p/90f5ec723175)
2. [iOS 静态库和动态库（库详解） - 俊华的博客 - 博客园](https://www.cnblogs.com/junhuawang/p/7598236.html)
3. [iOS专题2:静态库和动态库详解 - 简书](https://www.jianshu.com/p/c8366e4f9378)