# 工具-正则表达式


正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。

例如：

* runoo+b，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次）。

* runoo*b，可以匹配 runob、runoob、runoooooob 等，* 号代表字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。

* colou?r 可以匹配 color 或者 colour，? 问号代表前面的字符最多只可以出现一次（0次、或1次）。

## 贪婪模式

* 贪婪匹配是尽可能匹配多的字符
* 非贪婪匹配就是尽叮能匹配少的字符

在前面正则表达式匹配规则里，提到了 .*

. :匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用像 '[.\n]' 的模式

* :匹配0个或多个

使用 .* 的话就可以匹配任意长度的任意字符，但是有时候在使用 .*时就可能匹配不到物品们想要的结果，例：

import re
 
s='hello 1234567 world'
res = re.match('he.*(\d+).*rld$',s)
 
print(res.group(1))
这里要获取中间的数字，正则表达式这样写看似没什么问题，但是运行结果却只有 7 ，这是怎么回事呢？

这里就涉及一个贪婪匹配与非 贪婪匹配的问题了。在贪婪匹配下，.* 会匹配尽可能多的字符。正则表达式中.*后面是\d+，也就是至少一个数字，并没有指定具体多少个数字，因此，.*就尽可能匹配多的字符，这里就把123456匹配了，给\d+留下个可满 足条件的数字 7.最后得到的内容就只有数字7了。

           但这很明显会给我们带来很大的不便。有时候，匹配结果会莫名其妙少了部分内容。 其实，这里只需要使用非贪婪匹配就好了。非贪婪匹配的写法是.*?，多了一个?，那么它可以达到怎样的效果?我们再用实例看一下:

import re
 
s='hello 1234567 world'
res = re.match('he.*?(\d+).*rld$',s)
 
print(res.group(1))
 

这里我们只是将第一个.*改成了.*?. 转变为非贪婪匹配。结果如下:

           1234567

           此时就可以成功获取1234567了。原因可想而知，贪婪匹配是尽可能匹配多的字符，非贪婪匹配就是尽叮能匹配少的字符。当.*?匹配到hello后面的空白字符时，再往后的字符就是数字了，而\d+恰好可以匹配，那么这里. *?就不再进行匹配，交给\d+去匹配后面的数字。所以这样，*?匹配了尽可能少的字符，\d+ 的结果就是1234567了。

            但是这里需要注意，如果匹配的结果在字符结尾，.*?就有可能匹配不到任何结果了，因为他会尽可能匹配少的字符，例：

import re
 
s='hello 1234567 world/python'
res1 = re.match('he.*?(\d).*rld/(.*?)',s)
res2 = re.match('he.*?(\d).*rld/(.*)',s)
 
print('res1',res1.group(2))
print('res2',res2.group(2))
 

运行结果为：

res1

res2 python

可以观察到，.*?没有匹配到任何结果，而.*则尽可能匹配多的字符，成功得到了匹配结果。


### 图形化

[Regulex](https://jex.im/regulex/#!flags=&re=%5E(a%7Cb)*%3F%24)

## 参考

* [iOS深思篇 | 正则表达式 - 掘金](https://juejin.im/post/5d9c57fe6fb9a04e22332390#2.2%20%E5%88%9D%E8%AF%86%E7%AF%87)
* [正则表达式 – 简介 | 菜鸟教程](https://www.runoob.com/regexp/regexp-intro.html)
* [正则表达式30分钟入门教程 | 菜鸟教程](https://www.runoob.com/w3cnote/regular-expression-30-minutes-tutorial.html#introduction)
* [regex101](https://regex101.com/)