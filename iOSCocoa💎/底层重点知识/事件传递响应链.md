# 事件分发传递和响应链

![](http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu//15342642230888.jpg)

* 我们在手机上的一个触摸或点击，在手机系统中是怎么样一个过程:
* 其实首先就是手机屏幕和底层相关软硬件对这个触摸一个解析过程，将这个触摸解析event，然后iOS系统将这个event事件传递到相应的界面上，由界面来响应我们的操作，给出对应的反馈，这样一个交互过程。这其中传递的过程就是我们今天的要了解的主角。从图上可以看到，从window—view之间，具体是怎么样一个规律呢？ 先从这个触摸或点击开始了解一下：

事件的传递和响应分两个链：
传递链：由系统向离用户最近的view传递。UIKit –> active app’s event queue –> window –> root view –>……–>lowest view
响应链：由离用户最近的view向系统传递。initial view –> super view –> …..–> view controller –> window –> Application

1. 触摸屏幕产生触摸事件后，触摸事件会被添加到由UIApplication管理的事件队列中
2. UIApplication会从事件队列中取出最前面的事件，把事件传递给应用程序的主窗口，这时候执行**事件传递流程** 找到一个最合适的视图来处理触摸事件。（这时候如果某一个view上添加了手势，且**该手势能响应对应事件，则走手势的响应**，根据手势的设置来决定是否阻断下面的步骤，但是事件传递过程依旧。如没有或者不能响应则继续走下面步骤）
3. 最合适的view会调用自己的touches方法处理事件 如果需要的话可以把事件顺着响应者链条向上抛。

## UITouch与UIEvent

* 一次触摸将产生一个UITouch：一个手指离开屏幕前的一系列动作，包含时间戳、所在视图、 力度等信息。
* UIEvent：多个UITouch组成，也就是多个触摸组成。 一个event指的是第一个手指开始触摸到最后一个手指离开屏幕这段时间所有UITouch的总和。

那么这个UIEvent是如何在系统解析出来后，传递下去呢？哪些对象可以传递UIEvent呢？

## 事件传递

![](http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu//15342660793892.jpg)

上面已经介绍了某个控件在接收到点击事件时的处理，那么系统是怎么通过用户点击的位置找到处理点击事件的view的呢？

在上文我们已经说过了系统通过不断查找下一个响应者来响应点击事件，而所有的可交互控件都是UIResponder直接或者间接的子类，那么我们是否可以在这个类的头文件中找到关键的属性呢？

正好存在着这么一个方法：- (nullable UIResponder *)nextResponder，通过方法名我们不难发现这是获取当前view的下一个响应者，那么我们重写touchesBegan方法，逐级获取下一响应者，直到没有下一个响应者位置。相关代码如下：

```objc
- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event

{

    UIResponder * next = [self nextResponder];

    NSMutableString * prefix = @"".mutableCopy;

    while (next != nil) {

        NSLog(@"%@%@", prefix, [next class]);

        [prefix appendString: @"--"];

        next = [next nextResponder];

    }   

}

```
控制台输出的所有下级事件响应者如下：
```objc

AView

--UIView

----ViewController

------UIWindow

--------UIApplication

----------AppDelegate

```
虽然结果非常有层次，但是从系统逐级查找响应者的角度上来说，这个输出的顺序是刚好相反的。为什么会出现这种问题呢？我们可以看到输出中存在一个ViewController类，说明UIViewController也是UIResponder的子类。但是我们可以发现，controller是一个view的管理者，即便它是响应链的成员之一，但是按照逻辑来说，控制器不应该是系统查找对象之一，通过nextResponder方法查找的这个思路是不正确的。

后来，发现在UIView的头文件中存在这么两个方法，分别返回UIView和BOOL类型的方法：

```objc

- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;   // recursively calls -pointInside:withEvent:. point is in the receiver's coordinate system

- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;   // default returns YES if point is in bounds

```
根据方法名，一个是根据点击坐标返回事件是否发生在本视图以内，另一个方法是返回响应点击事件的对象。通过这两个方法，我们可以猜到，系统在收到点击事件的时候通过不断遍历当前视图上的子视图的这些方法，获取下一个响应的视图。因此，继续通过method_swizzling方式修改这两个方法的实现，并且测试输出如下：

```objc

UIStatusBarWindow can answer 1

UIStatusBar can answer 0

UIStatusBarForegroundView can answer 0

UIStatusBarServiceItemView can answer 0

UIStatusBarDataNetworkItemView can answer 0

UIStatusBarBatteryItemView can answer 0

UIStatusBarTimeItemView can answer 0

hit view: UIStatusBar

hit view: UIStatusBarWindow

UIWindow can answer 1

UIView can answer 1

hit view: _UILayoutGuide

hit view: _UILayoutGuide

AView can answer 1

DView can answer 0

hit view: DView

BView can answer 0

hit view: BView

hit view: AView

hit view: UIView

hit view: UIWindow

......  //下面是touches方法的输出

```
最上面的UIStatusBar开头的类型大家可能没见过，但是不妨碍我们猜到这是状态栏相关的一些视图，具体可以查找苹果的文档中心（Xcode中快捷键shift+command+0打开）。从输出中不难看出系统先调用pointInSide: WithEvent:判断当前视图以及这些视图的子视图是否能接收这次点击事件，然后在调用hitTest: withEvent:依次获取处理这个事件的所有视图对象，在获取所有的可处理事件对象后，开始调用这些对象的touches回调方法

通过输出的方法调用，我们可以看到响应查找的顺序是： UIStatusBar相关的视图 -> UIWindow -> UIView -> AView -> DView -> BView（系统在事件链传递的过程中一定会遍历所有的子视图判断是否能够响应点击事件），以本文demo为例，我们可以得出事件响应链查找的图示如下：

![9FADB1EE-2664-4DF2-9C4A-9C0AB5C60943](https://i.imgur.com/0xRrfe5.jpg)

那么在上面的查找响应者流程完成之后，系统会将本次事件中的点击转换成UITouch对象，然后将这些对象和UIEvent类型的事件对象传递给touchesBegan方法。不仅如此，从上面输出的nextResponder来看，所有的响应者都是在查找中返回可响应点击的视图。因此，我们可以推测出UIApplication对象维护着自己的一个响应者栈，当pointInSide: withEvent:返回yes的时候，响应者入栈。

![E146E0CA-C316-4975-BC11-97D4A22DB4A1](https://i.imgur.com/YNmULvR.jpg)

栈顶的响应者作为最优先处理事件的对象，假设AView不处理事件，那么出栈，移交给UIView，以此下去，直到事件得到了处理或者到达AppDelegate后依旧未响应，事件被摒弃为止。通过这个机制我们也可以看到controller是响应者栈中的例外，即便没有pointInSide: withEvent:的方法返回可响应，controller依旧能够入栈成为UIView的下一个响应者。

### 响应链应用


既然已经知道了系统是怎么获取响应视图的流程了，那么我们可以通过重写查找事件处理者的方法来实现不规则形状点击。最常见的不规则视图就是圆形视图，在demo中我设置view的宽高为200，那么重写方法事件如下:

```objc
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event
{
    const CGFloat halfWidth = 100;
    CGFloat xOffset = point.x - 100;
    CGFloat yOffset = point.y - 100;
    CGFloat radius = sqrt(xOffset * xOffset + yOffset * yOffset);
    return radius <= halfWidth;
}
```


## 响应者Responder

响应者就是可以接收到UIEvent的对象，也是可以最终响应用户的操作的对象。iOS开发中主要与四种对象可以作为responder：

![](http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu//15342644173252.jpg)

UIResponder作为响应者的基类，主要是定义了一些关于响应的属性和方法，用于子类判断或者执行关于响应的操作：

```objc
@interface UIResponder : NSObject <UIResponderStandardEditActions>

#if UIKIT_DEFINE_AS_PROPERTIES
@property(nonatomic, readonly, nullable) UIResponder *nextResponder;
#else
- (nullable UIResponder*)nextResponder;
#endif

#if UIKIT_DEFINE_AS_PROPERTIES
@property(nonatomic, readonly) BOOL canBecomeFirstResponder;    // default is NO
#else
- (BOOL)canBecomeFirstResponder;    // default is NO
#endif
- (BOOL)becomeFirstResponder;

#if UIKIT_DEFINE_AS_PROPERTIES
@property(nonatomic, readonly) BOOL canResignFirstResponder;    // default is YES
#else
- (BOOL)canResignFirstResponder;    // default is YES
#endif
- (BOOL)resignFirstResponder;

#if UIKIT_DEFINE_AS_PROPERTIES
@property(nonatomic, readonly) BOOL isFirstResponder;
#else
- (BOOL)isFirstResponder;
#endif

// Generally, all responders which do custom touch handling should override all four of these methods.
// Your responder will receive either touchesEnded:withEvent: or touchesCancelled:withEvent: for each
// touch it is handling (those touches it received in touchesBegan:withEvent:).
// *** You must handle cancelled touches to ensure correct behavior in your application.  Failure to
// do so is very likely to lead to incorrect behavior or crashes.
- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesMoved:(NSSet<UITouch *> *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesEnded:(NSSet<UITouch *> *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesCancelled:(NSSet<UITouch *> *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesEstimatedPropertiesUpdated:(NSSet<UITouch *> *)touches NS_AVAILABLE_IOS(9_1);

- (void)pressesBegan:(NSSet<UIPress *> *)presses withEvent:(nullable UIPressesEvent *)event NS_AVAILABLE_IOS(9_0);
- (void)pressesChanged:(NSSet<UIPress *> *)presses withEvent:(nullable UIPressesEvent *)event NS_AVAILABLE_IOS(9_0);
- (void)pressesEnded:(NSSet<UIPress *> *)presses withEvent:(nullable UIPressesEvent *)event NS_AVAILABLE_IOS(9_0);
- (void)pressesCancelled:(NSSet<UIPress *> *)presses withEvent:(nullable UIPressesEvent *)event NS_AVAILABLE_IOS(9_0);

- (void)motionBegan:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);
- (void)motionEnded:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);
- (void)motionCancelled:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);

- (void)remoteControlReceivedWithEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(4_0);

- (BOOL)canPerformAction:(SEL)action withSender:(nullable id)sender NS_AVAILABLE_IOS(3_0);
// Allows an action to be forwarded to another target. By default checks -canPerformAction:withSender: to either return self, or go up the responder chain.
- (nullable id)targetForAction:(SEL)action withSender:(nullable id)sender NS_AVAILABLE_IOS(7_0);

@property(nullable, nonatomic,readonly) NSUndoManager *undoManager NS_AVAILABLE_IOS(3_0);
```

这些responder在接受上一个responder传递而来的响应UIEvent，
这样依次传递响应的顺序就是一个响应链
如果将响应链顺序反向：就是UIEvent通过hit-test遍历的过程链。
责任传递就是处于应该响应顺序上的上一个对象有责任处理这个UIEvent，如果他不处理，就轮到响应链上的下一个来处理
也就是说刚才UIEvent的传递过程和响应链是两个互逆的顺序

其实系统是通过hit-test方法来决定哪个view作为最终响应用户操作的载体。hit-test是UIView的一个扩展方法，与其搭配的就是pointInside方法，
二者功能可以确定点击或者触摸的点是否在view的范围内，通过hit-test的返回值告诉系统当前view是否可以作为响应者。

### hit-test

理解hit-test就是理解响应链的核心点：
![](http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu//15342685872702.jpg)

iOS系统在判断哪个view来响应用户时 ，就是通过hit-test在所有view的“树”上遍历：当前内存中所有view的子类都会执行hit-test方法，逐个遍历每个叶子节点，如果叶子节点view上还有叶子，就进一步遍历下去。再啰嗦一句：即使某个view不会作为响应者，并且也不在点击范围内，只要它是当前显示的vc或者view的子视图，就会被httest遍历到，从而获取到是否可以作为响应者的信息。

![](http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu//15342650169673.jpg)

序号25的栈帧上，主线程的runloop接收到UIEvent，然后经由分发器，首先分发到window上，然后传递给UIView，然后16--13正式遍历这个UIView的所有叶子的过程。在遍历过程中，如果子节点的任何一个view在执行hit-test时返回了self（当前子view），就表示找到了响应的视图，这时父类也会通过返回值将这个子view向上返回，一直返回到window，返回到application，也就让系统知道了应该让谁来处理这个触摸。

注意：以下三种情况下，view将不会执行hit-test：

* hidden=YES
* userInteractionEnabled=NO
* alpha<0.01
* 视图超出父视图的区域


## 响应链

通过上面的hit-test遍历后，已经找到了响应者responder，由于其必然继承自UIResponder，我们可以重写UIResponder的touchBegan方法，touchBegan方法中再通过nextResponder属性来遍历地查看响应者链上的每个响应者：

```objc
-(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event
```

我们以下图来具体描述下响应者链：

![](http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu//15342652219666.jpg)


### 点击穿透

![](http://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu//15342666529651.jpg)

点击区域1和3，自然是不用说了。

那么，点击区域2，是响应哪个事件呢？

通过上面的hit-test遍历规则分析，我们该知道蓝色3区域是最后一个subview，后进先出，那么他应该是first reponder，所以点击2区域是响应蓝色按钮事件。

那么，既然我们的主题是事件穿透，那么肯定是希望红色2区域响应事件的。怎么做呢，肯定是要重写hit-test方法的，基本思路就是在点击2区域返回的是红色button，那么等于改写了hit-test规则，first responder就可以变成红色button。

那么，每个view都有hit-test，我们是在哪个view重写hit-test呢？

因为hit-test在传递事件遍历的时候是从父view到subviews，而subviews是从蓝色到红色。

然而在点击2区域的时候，遍历到蓝色的时候就已经返回了，根本不会调用红色button的hit-test。

所以，我们可以在蓝色view里重写，也可以在父view里重写hit-test。下面是在蓝色view里重写的hit-test

```objc
- (UIView *)hit-test:(CGPoint)point withEvent:(UIEvent *)event {
    CGPoint redBtnPoint = [self convertPoint:point toView:_redButton];
    if ([_redButton pointInside:redBtnPoint withEvent:event]) {
        return _redButton;
    }
    //如果希望严谨一点，可以将上面if语句及里面代码替换成如下代码
    //UIView *view = [_redButton hit-test: redBtnPoint withEvent: event];
    //if (view) return view;
    return [super hit-test:point withEvent:event];
}
```

如此，点击2区域，就会响应红色按钮就会响应事件。
这种透传有个前提：你要能获取到被挡住的view对象。

如果是私有的view对象，甚至通过runtime都获取不到该view对象。比如说appstore的下载按钮以及其他subviews，那就不能用这种方案。


## 总结

从上面可以看出，事件的传递方向是(hit-test就是事件的传递)：

```
UIApplication -> UIWindow ->ViewController-> UIView -> initial view
```

而Responder传递方向是(还记得nextResponder吗)：

```
Initial View -> Parent View -> ViewController -> Window -> Application
```


## 参考

1. [响应链的分析与应用 - 简书](https://www.jianshu.com/p/223320ceb494)
2. [ios事件传递和响应机制 - CSDN博客](https://blog.csdn.net/aa841538513/article/details/77046765)
3. [iOS事件响应链中Hit-Test View的应用 - 简书](https://www.jianshu.com/p/d8512dff2b3e#%E6%80%BB%E7%BB%93)
