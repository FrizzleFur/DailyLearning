## 数据类型
-------


oc中以@开头得都是Foundation框架得NSString类型的字符串。

oc有3中数据类型：基础类型，对象类型，id类型

* 基础类型不需要加＊，包括int、float、double、和char类型
* 对象类型指的是类或协议所声明的指针类型必须要加＊
* id类型可以表示任 意类型，但一般只表示对象类型

**@interface**部分定义了类名、继承的父类、实现的协议、成员变量和成员方法等信息，主要做定义成员变量和成员方法

**@implementation**部分实现了接口部分定义的成员方法，主要做了两件事：实现成员方法，以及对成员方法的初始化

> *   初始化由它的构造函数来做，所以第一步先定义构造函数，如果没有定义构造函数就是用默认的构造函数，然后再实现方法。

## 变量类型

**实例成员变量**、**类变量**、**实例方法**、**类方法**：

> *   实例成员变量：即对象变量，不用static修饰，放在@interface里面。实例变量的初始化用实例构造函数。
> *   类变量：即静态变量，用static修饰，放在@interface上面。类变量的初始化用类构造函数。
> *   实例方法：只能被实例个体调用，用－；实例方法可以访问类变量。
> *   类方法：可以被类直接调用，用+；类方法不能访问实例成员变量。


类体的定义包括成员变量的定义和方法的定义。

1、成员变量包括实例变量和类变量；而成员方法包括实例方法、类方法，当然还有一种特殊的构造方法。

2、类变量、类方法就是类中的变量、方法，必须是静态的，要加static；故其又称静态变量、静态方法。

3、成员变量、成员方法是对象或实例中的变量、方法，不加static；

类变量：静态域，静态字段，或叫静态变量，它属于该类所有实例共有的属性，在内存中只有一个地方存储这个变量。而且所有的实例都可以修改这个类变量的值（前提是这个类变量没有被final修饰，否则是常量了），而且访问类变量的时候不用实例，直接用类就可以了。

* 类方法：和类变量一样，可以不用实例，直接用类就可以调用类方法。

* 实例变量：实例域，实例字段，或叫成员变量。

* 实例方法：或叫成员方法，必须先有实例，然后才能通过实例调用该实例方法。

* 使用方法：类方法可以直接调用类变量和类方法

*  类方法不可以直接调用实例变量和实例方法

*  类方法中没有this，因为没有实例，this不知道调用哪个实例

*  类方法可以从类里面直接访问类成员

*  实例方法可以调用类方法，访问类变量，但是不提倡这样做，会把类方法和类变量混淆成实例方法和实例变量

### 成员变量

* 成员变量用于类内部，无需与外界接触的变量，成员变量默认是protected，一般情况下，非子类对象无法访问，因为成员变量不会生成set、get方法，所以外界无法与成员变量接触成员变量是定义在｛｝号中的变量，如果变量的数据类型是一个类则称这个变量为实例变量。 因为实例变量是成员变量的一种特殊情况，所以实例变量也是类内部使用的，无需与外部接触的变量，这个也就是所谓的类私有变量　

```objc
@interface MyViewController :UIViewController
{
    UIButton *yourButton; 
    int count; 
    id data； 
} 
```

* 成员变量生存与该类的生命周期，变量存活周期跟你定义的该类实体对象一样；
* 成员变量作用域是整个实体对象；


### 实例变量

实例变量本质上就是成员变量，只是实例是针对类而言， 编译器会自动为你生成以下划线开头的实例变量 _myButton，也会自动为你生成setter，getter方法。 如果.m文件中写了@synthesize myButton，那么生成的实例变量就是myButton；如果没写@synthesize myButton，那么生成的实例变量就是_myButton

**成员变量 = 实例变量 + 基本数据类型变量**


### 属性变量

* 根据成员变量的私有性**，为了方便访问，所以就有了属性变量。属性变量的好处就是允许让其他对象访问到该变量**（因为属性创建过程中自动产生了set 和get方法）。当然，你可以设置只读或者可写等，设置方法也可自定义。所以，属性变量是用于与其他对象交互的变量。

属性：使用getter和setter方法，太繁琐。因此提出了属性的概念。在接口定义部分，使用@property关键字，定义属性后就会产生get和set方法(如果不想让人访问，可以不定义属性)属性的调用和成员变量的调用是不一样的，因此通过调用的方式可以看出来调用的是成员变量的方式还是属性的方式。

一般我们把成员变量和属性明明相同，意味着这个属性是为了这个成员变量而封装的。其实属性并不真正保存数据，而是通过属性的set方法，绑定到成员变量里去了，属性是两个方法，通过这两个方法改变成员变量的值。 属性访问用. 成员变量访问用 -> 方法访问用[]

调用方法给成员变量赋值是不会发生内存泄漏和空指针异常的；直接赋值会出问题。记住一点：通过方法或者属性来访问成员变量。不要直接使用成员变量，直接使用属性就等于使用了它的set方法。

```objc
@interface MyViewController :UIViewController 
@property (nonatomic, strong) UIButton *myButton; 
@end
```
属性变量是用于与其他对象交互的变量。**属性变量的好处就是允许让其他对象访问到该变量**（因为属性创建过程中自动产生了set 和get方法）。 当然，你可以设置只读或者可写等，设置方法也可自定义。 现在大家似乎都不怎么喜欢用成员变量来定义类的变量， 都喜欢用属性变量来定义类的变量。把需要与外部接触的变量定义在.h文件中，只在本类中使用的变量定义在.m文件中

### 自动变量

1> 定义：自动变量是存储在堆栈中的。

2> 哪些是自动变量：被关键字auto修饰的局部变量都是自动变量，但是极少使用这个关键字，基本上是废的，因为所有的局部变量在默认情况下都是自动变量。

3> 生命周期：在程序执行到声明自动变量的代码块(函数)时，自动变量才被创建；当自动变量所在的代码块(函数)执行完毕后，这些自动变量就会自行销毁。如果一个函数被重复调用，这些自动变量每次都会重新创建。

### 局部变量

```objc
-（void）viewDidLoad 
{ 
    // 局部变量 
    NSArray *array = [[NSArray alloc] initWithObject:@“123”,nil]; 
} 
```

局部变量是根据其生存周期定义的，在源文件中的array，其生命周期是在以“{ }”为界限的代码块中，虽然它的名称与成员变量相同，但不是同一个变量


### 全局变量

定义：在@implementation外定义的变量（在@implementation中定义也是可以但是一般不这么干） 
举例： 

```objc
// 规范的
static int hu=3;// 全局变量 
NSString *str1= @"S1ViewController";// 全局变量 
@implementation S1ViewController 
@end 
```

全局变量分为两种

* static 修饰的  也称私有全局变量，只在该源文件中可用
* 没有static 修饰的 ，在任何源文件中都可以用，
* 注意：定义没有static的全局变量，命名一定要很独特，才能区分与其他源文件中的全局变量，如果出现跟其他源文件同名的全局变量，则会报错误

例如：
```objc
NSString*sttr1=@"S1ViewController";//全局变量  
```

在其他文件如果要用该全局变量，在前面加extern NSString*sttr1；即可使用了


### static变量

* (1) 函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次,因此其值在下次调用时仍维持上次的值;
* (2) 在模块内的static 全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问;
* (3) 在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内;
* (4) 在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝;
* (5) 在类中的static 成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。

## iOS下划线变量

Xcode4后 编译器自动建立了一个关联的实例变量， _x 就是那个自动创建的实例变量。

有一堆隐藏的(简化）代码如下：

```objc
NSString *_x;

-(NSString *)x {
    return _x;
}

-(void)setX:(NSString *)x {
    _x = x；
}

```

所以，`@synthesize x = _x;`做的就是实现桑面的代码。

[ios - Purpose of Synthesize - Stack Overflow](https://stackoverflow.com/questions/14658142/purpose-of-synthesize)

1. 首先通过self.xxx 通过访问的方法的引用：包含了set和get方法。而通过下划线是获取自己的实例变量，不包含set和get的方法。

2. self.xxx是对属性的访问；而_xxx是对局部变量的访问。所有被声明为属性的成员，再ios5之前需要使用编译指令@synthesize 来告诉编译器帮助生成属性的getter和setter方法，之后这个指令可以不用认为的指定了，默认情况下编译器会帮助我们生成。编译器在生成getter，setter方法时是有优先级的，他首先查找当前的类中用户是否定义属性的getter，setter方法，如果有，则编译器会跳过，不会再生成，使用用户定义的方法。也就是说你在使用self.xxx时是调用一个getter方法。会使引用计数加一，而_xxx不会使用引用技术加一的。    所有使用self.xxx是更好的选择，因为这样可以兼容懒加载，同时也避免了使用下滑线的时候忽略了self这个指针，后者容易在BLock中造成循环引用。同时，使用 _是获取不到父类的属性，因为它只是对局部变量的访问。

3. 最后总结：self方法实际上是用了get和set方法间接调用，下划线方法是直接对变量操作。


### property

编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。 所以你也可以这么说：

```
@property = ivar + getter + setter;
```

“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。


“自动合成”( autosynthesis)

完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译 器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。**除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字**。在前例中，会生成两个实例变量，其名称分别为 _firstName 与 _lastName。也可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字.


### 应用场景

* 私有变量
对外只读，就不会生成setter，如果需要重写getter方法，可以
```objc
// .h
@property(nonatomic, strong, readonly) NSObject *privateObj;
// .m
@synthesize privateObj = _privateObj;

```

[iOS 实现只读属性的几种方法 - 简书](https://www.jianshu.com/p/3033b306126a)


### @protocol 和 category 中如何使用 @property

* 在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性

* category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数：

* objc_setAssociatedObject

* objc_getAssociatedObject



## 参考

1. [成员变量、实例变量、类变量、成员方法、实例方法、类方法的区别](https://blog.csdn.net/wuha0/article/details/7084136)
2. [IOS 成员变量，属性变量，局部变量，实例变量，全局变量 详解 - CSDN博客](https://blog.csdn.net/chenshun123/article/details/52280564)
3. [iOS 成员变量，实例变量，属性变量的区别，联系 - Jenaral - 博客园](https://www.cnblogs.com/Jenaral/p/5970393.html)