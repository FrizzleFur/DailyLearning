# 项目-问题回顾

## UI

### 首页下拉和吸顶的问题

首页先往上拉，在下拉，就无法获取ScrollView正确的contentOffset，造成MJ的Inset错误刷新失效！！在`handleSubScrollDidScroll`方法中有问题，可否KVO
1. child scrollview的bounce需要设置，以便在临界点触发过度阶段。
2. 下拉过程，快速滑动的过程中，child scrollview超过临界点后contentOffsetY每次被更新为0，然后main scrollview会停止滚动。

#### 需求： 

需要一个包含头视图的类似网易新闻的tabBar，下面是列表的结构.

* tabbar在顶部顶部下面的时候，整体外部滚动。
* tabbar在滚动到顶部的时候吸顶，切换到子视图滚动。
* 支持整体下拉刷新。

![](http://oc98nass3.bkt.clouddn.com/15393193121117.jpg)

这里使用了通知来监听内外层ScrollView滚动的偏移量

在用户点击内层scrollView进行拉去的时候，需要让外层也获取到滚动，所以外层的scrollView需要接受到内层的滚动范围。

```objc

@interface GestureScrollView : UIScrollView

/** 同时识别多个手势
 @param gestureRecognizer gestureRecognizer description
 @param otherGestureRecognizer otherGestureRecognizer description
 @return return value description
 */
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer {
    return YES;
}

```

在主视图中，保存子视图的滑动视图。

```objc
/** 子VC的滚动视图scrollView */
@property (nonatomic, strong) UIScrollView *childVCScrollView;
#pragma mark - NSNotification

- (void)handleSubScrollDidScroll:(NSNotification *)notification{
    UIScrollView *subScroll = notification.userInfo[kPostSubScrollView];
    if (![subScroll isKindOfClass:[UIScrollView class]]) return;
    self.childVCScrollView = subScroll;
    BOOL mainScrollEnable = (self.mScrollView.mj_offsetY < self.tabBar.top);
    if (mainScrollEnable) [subScroll setContentOffset:CGPointZero];
}
```
1. 主视图滚动时


```objc
- (void)scrollViewDidScroll:(UIScrollView *)scrollView{
    CGFloat offsetY = self.mScrollView.contentOffset.y;
    // 主视图是否偏移到临界点
    BOOL mainScrollOffInChild = offsetY > self.tabBar.top;
    // 子视图是否偏移
    BOOL childScrollOffs = (self.childVCScrollView && _childVCScrollView.contentOffset.y > 0);
    
    if (mainScrollOffInChild || childScrollOffs) {
        // 滚到子视图范围内
        [self.mScrollView setContentOffset:CGPointMake(0, self.tabBar.top)];
    }else{
        // 在外主视图范围内
        [[NSNotificationCenter defaultCenter] postNotificationName:kPostSubScrollViewScrollToTop object:nil];
    }
}
```

1. 子视图添加监听，如果主视图通知子视图，滚动在外主视图范围内，则让视图的scroll滚动到顶部

```objc
/** 让视图的scroll滚动到顶部 */
- (void)childScrollViewScrollToTop {
    _collectionView.contentOffset = CGPointZero;
}

```

-------

* 还有种思路就是tabbar交给table的`sectionHeader`,子视图放在一个横向滚动的tableViewCell中,就比较简单，[liuzhongning/NNJaneBookView: 仿简书个人主页多页面滑动视图。](https://github.com/liuzhongning/NNJaneBookView/tree/fa7c984710a13f6431a5d5bba12292e5a9c3f2b5)

参考 


* [JXPageListView](https://github.com/pujiaxin33/JXPageListView)
* [iOS:高仿闲鱼、京东等列表底部分页视图 | iOSCaff - 专业的 iOS 开发者社区](https://ioscaff.com/articles/215)
* [HVScrollView](https://github.com/SPStore/HVScrollView)
* [liuzhongning/NNJaneBookView: 仿简书个人主页多页面滑动视图。](https://github.com/liuzhongning/NNJaneBookView/tree/fa7c984710a13f6431a5d5bba12292e5a9c3f2b5)


###  导航的懒加载问题

##### 导航的懒加载：

- 为了实现懒加载刷新，每次在点击tabbar的时候，实现添加方法，
* 每个子页面添加MJ的下拉刷新，在初始化页面的时候调用`MJRefresh`的`beginRefreshing`方法实现请求API。
* 在每个子页面初始化的时候，因为还未显示`MJRefresh`,所以`beginRefreshing`无法立即执行；
* 当点击tabar展示对应的自控制器的view的时，就会调用`beginRefreshing`，从而实现懒加载

> 首页选择第三个tab,下拉刷新到定义一个tab,然后滚动到底3个tab,发现第三个没有执行刷新
> 问题是因为在点击第三个时候，记录当前点击为第三个，然后下拉刷新后强制改为0；

```objc
[self.mSlideView reloadData];
self.mSlideView.selectedIndex = 0;
```
第一步： `self.mSlideView`在刷新的时候会默认选择当前index做添加，执行`addChildViewWithIndex`，使得当前所选的自控制器，也就是VC3得到刷新，然而整体刷新会让`self.mSlideView`滚动到第一页VC1,此时VC3已经刷新，就不会再次刷新。
第二步： 为了纠正第一步的问题，强制调用选择到第一个的index,

解决： 在重载数据时候，选择第一个，并将其滚动到第一个初始位置即可。

```objc
// 重载数据
- (void)reloadData {
    [_viewControllers removeAllObjects];

    NSUInteger count = [self.delegate numberOfTabsInSlideView:self];
    for (int i = 0; i < count; i++) {
        UIViewController *viewController = [self.delegate slideView:self viewForTabIndex:i];
        [_viewControllers addObject:viewController];
    }
    _scrollView.contentSize = CGSizeMake(self.frame.size.width * _viewControllers.count, 0);
    [self setSelectedIndex:0];
    [self addChildViewWithIndex:0];
}
```

### 导航栏的显示问题

> 之前定义导航栏在每个VC是否隐藏是，通过在VC的分类中利用`Runtime`添加一个`Bool`属性，结合自定义的Navi的`willShowViewController`方法中，对将要展示的每个VC设限制导航是否显示。
> 但是有一个页面在执行返回事件时候需要回到栈底的根VC，调用`popToRootViewControllerAnimated`时候，发现Navi不会执行`willShowViewController`方法：

```objc

// BaseNaviController
#pragma mark - UINavigationControllerDelegate
- (void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated {
    // 判断要显示的控制器是否是自身控制器
    [self setNavigationBarHidden:viewController.isHideNavBar animated:YES];
}

#import "UIViewController+Category.h"

// 属性绑定
#pragma mark ---------- 是否隐藏导航条 ----------
- (void)setIsHideNavBar:(BOOL)isHideNavBar
{
    /*
     objc_AssociationPolicy参数使用的策略：
     OBJC_ASSOCIATION_ASSIGN;            //assign策略
     OBJC_ASSOCIATION_COPY_NONATOMIC;    //copy策略
     OBJC_ASSOCIATION_RETAIN_NONATOMIC;  // retain策略
     
     OBJC_ASSOCIATION_RETAIN;
     OBJC_ASSOCIATION_COPY;
     */
    /*
     关联方法：
     objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);
     
     参数：
     * id object 给哪个对象的属性赋值
     const void *key 属性对应的key
     id value  设置属性值为value
     objc_AssociationPolicy policy  使用的策略，是一个枚举值，和copy，retain，assign是一样的，手机开发一般都选择NONATOMIC
     */
    objc_setAssociatedObject(self, &isHiddenKey, @(isHideNavBar), OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

- (BOOL)isHideNavBar
{
    return [objc_getAssociatedObject(self, &isHiddenKey) boolValue];
}

```


* From documentation:  popToRootViewControllerAnimated: Pops all the view controllers on the stack except the root view controller and updates the display.

* popViewControllerAnimated: Pops the top view controller from the navigation stack and updates the display.

[ios - navigationController:willShowViewController:animated: is not called after popToRootViewControllerAnimated in presented view controller - Stack Overflow](https://stackoverflow.com/questions/51825238/navigationcontrollerwillshowviewcontrolleranimated-is-not-called-after-poptor)

**原因：**
其实是会调用一次的，后来发现是以为该页面改成Feed流形式后，继承UINavigationControllerDelegate，自定义了转场动画,调用PushVC的时候，其实没有走原来的Push方法，造成不调用navi代理。




### 首页滚动右侧范围点击失去焦点

首页切换到明星主页，然后回到主页，往上滚动一点，右侧点击范围不到，点击左侧后又恢复了。修改了明星主页的Scroll特性后，发现是关闭全局的滚动调整后就会影响到滚动间距的问题`[[UIScrollView appearance] setContentInsetAdjustmentBehavior:(UIScrollViewContentInsetAdjustmentNever)];`

用于确定调整后的内容偏移的行为。
此属性指定如何使用安全区域insets来修改滚动视图的内容区域。此属性的默认值为UIScrollViewContentInsetAdjustmentAutomatic。

###  UIScrollView自动调整内容间距

发现在一个UIScrollView页面中，隐藏顶部导航的时候，会空出状态栏的高度，

```objc
 // 取消自动调整内容内间距
    if (@available(iOS 11.0, *)) {
        UIScrollView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;
    } else {
        // Fallback on earlier versions
    」
```

###  iOS11系统Tabbar的问题
 
 ![](https://i.loli.net/2018/11/06/5be140e2ec984.jpg)

经过测试发现，如果使用系统OS12.1 UINavigationController + UITabBarController（ UITabBar 磨砂），在popViewControllerAnimated 会遇到tabbar布局错乱的问题：

```objc
- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated{
   
   if (self.childViewControllers.count > 0) {
       //如果没这行代码，是正常显示的
       viewController.hidesBottomBarWhenPushed = YES;
   }
   
   [super pushViewController:viewController animated:animated];
}

```

这个问题是 iOS 12.1 Beta 2 引入的问题，只要 UITabBar 是磨砂的，并且 push viewController 时 hidesBottomBarWhenPushed = YES 则手势返回的时候就会触发，出现这个现象的直接原因是 tabBar 内的按钮 UITabBarButton 被设置了错误的 frame，frame.size 变为 (0, 0) 导致的。
所以最简单的解决方案就是：

```objc
[UITabBar appearance].translucent = NO;
```
 
 
 实测这个问题是 iOS 12.1 Beta 2 的问题，只要 UITabBar 是磨砂的，并且 push viewController 时 hidesBottomBarWhenPushed = YES 则手势返回的时候就会触发。

出现这个现象的直接原因是 tabBar 内的按钮 UITabBarButton 被设置了错误的 frame，frame.size 变为 (0, 0) 导致的。

如果需要，可以使用以下临时修补代码，待发布的 QMUI 新版里也会带上这部分代码，等到 iOS 12.1 正式版发布后如果这个问题被修复，我们也会把这段代码移除。

```objc
+ (void)load {
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        if (@available(iOS 12.1, *)) {
            OverrideImplementation(NSClassFromString(@"UITabBarButton"), @selector(setFrame:), ^id(__unsafe_unretained Class originClass, SEL originCMD, IMP originIMP) {
                return ^(UIView *selfObject, CGRect firstArgv) {
                    
                    if ([selfObject isKindOfClass:originClass]) {
                        // 如果发现即将要设置一个 size 为空的 frame，则屏蔽掉本次设置
                        if (!CGRectIsEmpty(selfObject.frame) && CGRectIsEmpty(firstArgv)) {
                            return;
                        }
                    }
                    
                    // call super
                    void (*originSelectorIMP)(id, SEL, CGRect);
                    originSelectorIMP = (void (*)(id, SEL, CGRect))originIMP;
                    originSelectorIMP(selfObject, originCMD, firstArgv);
                };
            });
        }
    });
}

```


* [iOS12.1 使用 UINavigationController + UITabBarController（ UITabBar 磨砂），设置hidesBottomBarWhenPushed后，在 pop 后，会引起TabBar布局异常 · Issue #3 · ChenYilong/iOS12AdaptationTips](https://github.com/ChenYilong/iOS12AdaptationTips/issues/3)
* [ios12.1 tabBar 中的图标及文字出现位置偏移动画 - Longge_Li的博客 - CSDN博客](https://blog.csdn.net/Longge_Li/article/details/83654333)
* [UITabBar layout is broken on iOS 12.1 · Issue #410 · QMUI/QMUI_iOS](https://github.com/QMUI/QMUI_iOS/issues/410)
 

### Push的偏移

在UINavigationController的基类重写pushViewController代理方法，在Push的时候修正一下TabBar的frame

[适配iPhone X Push过程中TabBar位置上移 - 简书](https://www.jianshu.com/p/719ab369d011)

```objc
@property (nonatomic) UIEdgeInsets oldSafeAreaInsets;

- (void) safeAreaInsetsDidChange{
    [super safeAreaInsetsDidChange];
    if(self.oldSafeAreaInsets.left != self.safeAreaInsets.left ||
       self.oldSafeAreaInsets.right != self.safeAreaInsets.right ||
       self.oldSafeAreaInsets.top != self.safeAreaInsets.top ||
       self.oldSafeAreaInsets.bottom != self.safeAreaInsets.bottom)
    {
        self.oldSafeAreaInsets = self.safeAreaInsets;
        [self invalidateIntrinsicContentSize];
        [self.superview setNeedsLayout];
        [self.superview layoutSubviews];
    }
    
}

- (CGSize) sizeThatFits:(CGSize) size{
    CGSize s = [super sizeThatFits:size];
    if(@available(iOS 11.0, *))
    {
        CGFloat bottomInset = self.safeAreaInsets.bottom;
        if( bottomInset > 0 && s.height < 50) {
            s.height += bottomInset;
        }
    }
    return s;
}
```
#### 方法二

还没有试用过

```objc
兼容iPhoneX的话可以在Block里面添加下面代码：


static CGFloat const kIPhoneXTabbarButtonErrorHeight = 33;
static CGFloat const kIPhoneXTabbarButtonHeight = 48;

return ^(UIView *selfObject, CGRect firstArgv) {

        if ([selfObject isKindOfClass:originClass]) {
            // 如果发现即将要设置一个 size 为空的 frame，则屏蔽掉本次设置
            if (!CGRectIsEmpty(selfObject.frame) && CGRectIsEmpty(firstArgv)) {
                return;
            }
        }
        
        //兼容IphoneX
        if (firstArgv.size.height == kIPhoneXTabbarButtonErrorHeight) {
            firstArgv.size.height = kIPhoneXTabbarButtonHeight;
        }
        
        // call super
        void (*originSelectorIMP)(id, SEL, CGRect);
        originSelectorIMP = (void (*)(id, SEL, CGRect))originIMP;
        originSelectorIMP(selfObject, originCMD, firstArgv);

 };
```

#### iphoneX的push偏移问题

* [适配iPhone X Push过程中TabBar位置上移 - 简书](https://www.jianshu.com/p/719ab369d011)
* [iOS 11 iPhone X simulator UITabBar icons and titles being rendered on top covering eachother - Stack Overflow](https://stackoverflow.com/questions/46214740/ios-11-iphone-x-simulator-uitabbar-icons-and-titles-being-rendered-on-top-coveri)

### hitTest方法的调用

 Tabbar中间Item按钮，二级页里也会触发.原因:检测tabbar中间点击范围的时候，调用hitTest方法中返回了starTabBarBtn，导致调用UITabBarController的点击事件代理。

### iOS 11 刷新tableview 视图漂移或者抖动

在做cell点击展开和关闭的时候，发现会有抖动的状态

```objc
    // 展开点击cell
    StarRankModel *rankModel = self.rankStarList[indexPath.row];
    // 修改状态
    rankModel.openTip = !rankModel.openTip;
    
    NSMutableArray <NSIndexPath *>*indexPathArr = [NSMutableArray arrayWithObject:indexPath];
    
    // 关闭上次点开的cell
    BOOL hasLastPath = (self.lastSelectedIndexPath && (self.lastSelectedIndexPath.row < self.rankStarList.count) && (self.lastSelectedIndexPath.row != indexPath.row));
    if (hasLastPath) {
        StarRankModel *lastRankModel = self.rankStarList[self.lastSelectedIndexPath.row];
        lastRankModel.openTip = false;
        [indexPathArr addObject:self.lastSelectedIndexPath];
    }
    [self.mTable reloadRowsAtIndexPaths:indexPathArr withRowAnimation:UITableViewRowAnimationFade];
```

这个应该是UITableView最大的改变。我们知道在iOS8引入`Self-Sizing` 之后，我们可以通过实现estimatedRowHeight相关的属性来展示动态的内容，实现了estimatedRowHeight属性后，得到的初始contenSize是个估算值，是通过estimatedRowHeight x cell的个数得到的，并不是最终的contenSize，tableView不会一次性计算所有的cell的高度了，只会计算当前屏幕能够显示的cell个数再加上几个，滑动时，tableView不停地得到新的cell，更新自己的contenSize，在滑到最后的时候，会得到正确的contenSize。
如果目前项目中没有使用estimateRowHeight属性，在iOS11的环境下就要注意了，因为开启Self-Sizing之后，tableView是使用estimateRowHeight属性的，这样就会造成contentSize和contentOffset值的变化，如果是有动画是观察这两个属性的变化进行的，就会造成动画的异常，因为在估算行高机制下，contentSize的值是一点点地变化更新的，所有cell显示完后才是最终的contentSize值。因为不会缓存正确的行高，tableView reloadData的时候，会重新计算contentSize，就有可能会引起contentOffset的变化。iOS11下不想使用Self-Sizing的话，可以通过以下方式关闭：


```objc
self.tableView.estimatedRowHeight = 0;
self.tableView.estimatedSectionHeaderHeight = 0;
self.tableView.estimatedSectionFooterHeight = 0;
```

我直接在初始化table的时候给estimatedRowHeight赋值一个初始值就不会自适应了。

```objc
_mTable.estimatedRowHeight = StarRankCell_CellHeight_Default;
```

或者主动实现estimatedHeightForRowAtIndexPath代理方法

```objc
- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath{
    StarRankModel *rankModel = self.rankStarList[indexPath.row];
    CGFloat cellHeight = [StarRankCell cellHeightWithModel:rankModel];
    return cellHeight;
}
```
　　注意:  tableView 返回估算高度方法里虽然我们返回了准确的高度，但 cell 最终的高度并不是以估算高度为准，而是取决于 cell 内约束，即 cell 是被约束撑满的。

　　所以 cell 的实际高度取决于设置数据时的里面 label.numberOfLines。这里返回的高度让系统减少估算的调整，所以这样动画就流畅了。

参考：
*  [iOS 11 刷新tableview 视图漂移或者抖动 - 简书](https://www.jianshu.com/p/5e19465f000e)
*  [ios-tableViewcell展开与收缩动画处理 - 布尔- - 博客园](https://www.cnblogs.com/buerjj/p/8613676.html)


### 子视图xib的Frame问题

> 父视图frame改变后子视图如果是xib,需要重新赋值Frame吗？

发现如果子视图是xib，父视图改变高度后，子视图需要更新约束吗？

```objc
/** 刷新视图布局 */
- (void)reloadViewsLayoutByModel:(PostModel *)postModel{
    // update top frame

    CGFloat groupFloatBtmH = postModel.isStarTypeBigV ? 0 : MGroupFloatView_DefaultH;
    mScrollView.height = ViewHeight_Navi - groupFloatBtmH;
    
    // 父视图frame改变后子视图如果是xib,需要重新赋值Frame;
    self.btnToolBar.height = btnToolBarH;

```


### HTML转富文本

```objc
NSString * htmlString = @"<html><body> Some html string </body></html>";
NSAttributedString * attrStr = [[NSAttributedString alloc] initWithData:[htmlString dataUsingEncoding:NSUnicodeStringEncoding] options:@{ NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType } documentAttributes:nil error:nil];

UILabel * myLabel = [[UILabel alloc] init];
myLabel.attributedText = attrStr;
```


```objc
- (NSAttributedString *)attributedStringWithHTMLString:(NSString *)htmlString

{

NSDictionary *options = @{ NSDocumentTypeDocumentAttribute : NSHTMLTextDocumentType,

NSCharacterEncodingDocumentAttribute :@(NSUTF8StringEncoding) };

NSData *data = [htmlString dataUsingEncoding:NSUTF8StringEncoding];

return [[NSAttributedString alloc] initWithData:data options:options documentAttributes:nil error:nil];

}
```
 
- 参考：
    - 1. [How to show an HTML string on a UILabel in iOS? - Stack Overflow](https://stackoverflow.com/questions/19946251/how-to-show-an-html-string-on-a-uilabel-in-ios)
    - 2. [iOS 开发_NSAtrributeString与HTML之间的相互转换 - 简书](https://www.jianshu.com/p/aa92f597ed55)
 

### 富文本点击问题

1. 使用UITextView可以实现link点击，但是如果使用Label,需要遍历link，然后添加。

[ios - nsattributedstring link uilabel - How can I make a clickable link in an NSAttributedString? - CODE Q&A Solved](https://code.i-harness.com/en/q/14a0b58)

提供一种添加link,的方式
```objc
I needed to keep using a pure UILabel, so called this from my tap recognizer (this is based on malex's response here: Character index at touch point for UILabel )

UILabel* label = (UILabel*)gesture.view;
CGPoint tapLocation = [gesture locationInView:label];

// create attributed string with paragraph style from label

NSMutableAttributedString* attr = [label.attributedText mutableCopy];
NSMutableParagraphStyle* paragraphStyle = [NSMutableParagraphStyle new];
paragraphStyle.alignment = label.textAlignment;

[attr addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, label.attributedText.length)];

// init text storage

NSTextStorage *textStorage = [[NSTextStorage alloc] initWithAttributedString:attr];
NSLayoutManager *layoutManager = [[NSLayoutManager alloc] init];
[textStorage addLayoutManager:layoutManager];

// init text container

NSTextContainer *textContainer = [[NSTextContainer alloc] initWithSize:CGSizeMake(label.frame.size.width, label.frame.size.height+100) ];
textContainer.lineFragmentPadding  = 0;
textContainer.maximumNumberOfLines = label.numberOfLines;
textContainer.lineBreakMode        = label.lineBreakMode;

[layoutManager addTextContainer:textContainer];

// find tapped character

NSUInteger characterIndex = [layoutManager characterIndexForPoint:tapLocation
                                                  inTextContainer:textContainer
                         fractionOfDistanceBetweenInsertionPoints:NULL];

// process link at tapped character

[attr enumerateAttributesInRange:NSMakeRange(characterIndex, 1)
                                         options:0
                                      usingBlock:^(NSDictionary<NSString *,id> * _Nonnull attrs, NSRange range, BOOL * _Nonnull stop) {
                                          if (attrs[NSLinkAttributeName]) {
                                              NSString* urlString = attrs[NSLinkAttributeName];
                                              NSURL* url = [NSURL URLWithString:urlString];
                                              [[UIApplication sharedApplication] openURL:url];
                                          }
                                      }];
```

## 动画

### 浮层的动画问题

```objc
// 在动画期间，对于要动画的视图暂时禁用用户交互
// 原因是对UIView的动画理解还不够，执行的时候，从之前的状态到动画终点的状态，然后是完成的回调。
// 之前的问题代码
    [UIView animateWithDuration:0.25 animations:^{
        self.view.alpha = 1.0;
        self->taskFloatView.bottom = self.view.bottom;
    } completion:^(BOOL finished) {
        self->taskFloatView.bottom = self.view.bottom;
        self->taskFloatView.hidden = false;
    }];

// 修改后的代码
    [UIView animateWithDuration:0.25 animations:^{
        self.view.alpha = 1.0;
        self->taskFloatView.hidden = false;
        self->taskFloatView.bottom = self.view.bottom;
    } completion:nil];

```
 
## 数据 


###  浮点数精度问题

* 用float类型接受服务端数据会有精度丢失的问题

现在解决方式是：

```objc
/*
 修正浮点型精度丢失
 @param serverStr 传入接口取到的数据
 @return 修正精度后的数据
 */
+  (NSString *)reviseFloatString:(NSString *)serverStr
{
    //直接传入精度丢失有问题的Double类型
    double conversionValue = [serverStr doubleValue];
    NSString *doubleString = [NSString stringWithFormat:@"%lf", conversionValue];
    NSDecimalNumber *decNumber = [NSDecimalNumber decimalNumberWithString:doubleString];
    return [decNumber stringValue];
}
```

* [iOS 关于网络数据解析小数位精度丢失问题的修正 - txz_gray的博客 - CSDN博客](https://blog.csdn.net/txz_gray/article/details/53303918)
* [深入浅出iOS浮点数精度问题 (上) - 简书](https://www.jianshu.com/p/9cbed21f37fe#%E6%B5%AE%E7%82%B9%E6%95%B0%E5%80%BC%20=%20(-1)%20^%20S%20*%20(%202%20^%20E)%20*%20M)


### NSMutableArray 深浅拷贝的类型问题

**NSMutableArray用copy修饰之后，在使用addObjectsFromArray方法时崩溃**
这个问题主要是误写导致的，只需要把copy改成strong。

**把NSMutableArray用copy修饰有时就会crash，因为对这个数组进行了增删改操作，而copy后的数组变成了不可变数组NSArray，没有响应的增删改方法**，所以对其进行增删改操作就会报错。


```objc
/** 商品列表 */
@property (nonatomic, copy) NSMutableArray <ProductModel *>*productModelList;

```

**NSMutableArray用copy修饰之后，在使用addObjectsFromArray方法时崩溃**

error：[__NSFrozenArrayM addObjectsFromArray:]: unrecognized selector

这个错误误导点：ArrayM这个让开发者认为是可变数组。但是因为你是用copy修饰的，所以这个数组其实是一个不可变数组。

这个问题主要是误写导致的，只需要把copy改成strong。

参考 [copy修饰可变数组造成的问题 - 简书](https://www.jianshu.com/p/29641ab41a39)


### 可变数组的对象位置

`indexOfObject vs. indexOfObjectIdenticalTo`
[objective c - indexOfObject vs. indexOfObjectIdenticalTo - Stack Overflow](https://stackoverflow.com/questions/3167849/indexofobject-vs-indexofobjectidenticalto)
在一个可变数组中，indexOfObject 和 indexOfObjectIdenticalTo是不同的
* indexOfObject： Returns the lowest index whose corresponding array value is **equal** to a given object.
* indexOfObjectIdenticalTo： Returns the lowest index whose corresponding array value is **identical** to a given object.


indexOfObjectIdenticalTo更加精确反应对象在数组中位置，而indexOfObject只是判断是否相等。如果没有刷新数组的赋值，建议用`indexOfObjectIdenticalTo`


```
indexOfObjectIdenticalTo checks for the exact same id (same address).  indexOfObject checks that isEqual: returns YES.
```

## 条件判断
 
 在比较数据的时候，一个判断条件

```
    if (lastList.count == currentList.count)

```
* 如果lastList.count为0. 就直接跳出了条件判断！
 
 
``` objc
/** 比较关注列表 */
- (BOOL)compareFocusListByLastList:(NSArray<StarModel *> *)lastList currentList:(NSArray<StarModel *> *)currentList{
    __block BOOL hasFocusListChanged = false;// 关注列表是否改变
    // 比较关注数量
    if (lastList.count == currentList.count){
        //个数相同的情况，比较每个的id是否一样
        [lastList enumerateObjectsUsingBlock:^(StarModel * _Nonnull lastModel, NSUInteger idx, BOOL * _Nonnull stop) {
            // 使用starId判断是否是同一个明星
            NSPredicate *starIdPredicate = [NSPredicate predicateWithFormat:@"starId = %@", lastModel.starId];
            // 是否含有相同starId的StarModel
            NSArray *sameStarModelArr = [currentList filteredArrayUsingPredicate:starIdPredicate];
            // 当前列表找到不到该starId的StarModel --> 发生了改变
            if (sameStarModelArr.count == 0){
                hasFocusListChanged = true;
                *stop = true;// 有变化则停止遍历
            }
        }];
    }else{
        // 关注数量发生变化
        hasFocusListChanged = true;
    }

```
 
 

## 网络

> 我需要在我们的应用程序中阻止一个HTTP请求的一个参数值的URL编码，因为它在传递给AFNetworking之前已经被编码

[ios - How to invoke default behaviour when using AFNetworking's setQueryStringSerializationWithBlock - Stack Overflow](https://stackoverflow.com/questions/26675591/how-to-invoke-default-behaviour-when-using-afnetworkings-setquerystringserializ)

`AFNetworking`的序列化,请求 AFHTTPRequestSerializer 会默认序列化一次，可以自定义序列化。


```objc
/**
 设置序列化类型的方法，代表遵循什么样的规则进行queryString转换。
 参数是个枚举，但是这个枚举只有一个值 AFHTTPRequestQueryStringDefaultStyle
 */
- (void)setQueryStringSerializationWithStyle:(AFHTTPRequestQueryStringSerializationStyle)style;

/**
 提供了以 block 形式自定义 queryString 转换的接口，
 也就是说可以通过block回调的方式让调用者以自己的方式完成 queryString 的转换。
 */
- (void)setQueryStringSerializationWithBlock:(nullable NSString * (^)(NSURLRequest *request, id parameters, 
                                             NSError * __autoreleasing *error))block;

```

返回值是拼接好的query string

```objc
    // 序列化自定义
    [self.requestSerializer setQueryStringSerializationWithBlock:^NSString * _Nonnull(NSURLRequest * _Nonnull request, id  _Nonnull parameters, NSError * _Nullable __autoreleasing * _Nullable error) {
        return hitsHttpRqsModel.paramStr;
    }];

```
 
## Web

### 网页加载完返回的崩溃

原因：加载网页会调用多次，每次去pop造成页面崩溃。

```objc
- (void)webViewDidFinishLoad:(UIWebView *)webView {
 // call request
     [[HttpClient sharedClient] postRequest:HTTP_COMMAND_HITS_BINDHITSACCOUNT serviceType:(HTTP_SERVICE_USER) params:params success:^(id responseObject) {
// success
    // 返回上个页面，web需要置空
    [self.navigationController popViewControllerAnimated:true];
```


### Web加载JS

不需要加载Html的方式

[xcode - Loading javascript into a UIWebView from resources - Stack Overflow](https://stackoverflow.com/questions/5733883/loading-javascript-into-a-uiwebview-from-resources)

```objc
- (void)webViewDidFinishLoad:(UIWebView *)webView {
    NSString *jsFile = @"jquery-1.8.2.min.js";
    NSString *jsFilePath = [[NSBundle mainBundle] pathForResource:jsFile ofType:nil];
    NSURL *jsURL = [NSURL fileURLWithPath:jsFilePath];
    NSString *javascriptCode = [NSString stringWithContentsOfFile:jsURL.path encoding:NSUTF8StringEncoding error:nil];
    [webView stringByEvaluatingJavaScriptFromString:javascriptCode];
    // ...
}
```


## Xcode问题 


###  打包问题

```objc
ld: could not reparse object file in bitcode bundle: 'Invalid bitcode version (Producer: '1000.11.45.2_0' Reader: '902.0.39.2_0')', using libLTO version 'LLVM version 9.1.0, (clang-902.0.39.2)' for architecture armv7
clang: error: linker command failed with exit code 1 (use -v to see invocation)
```

![](https://i.loli.net/2018/10/26/5bd2ac06c93f2.jpg)

分析：
项目中框架是使用Xcode 10编译的，但我使用的是Xcode 9.4.1（看起来像900.0.39.2_0是Xcode 9.2而902.0.39.2_0是Xcode 9.4）。我通过在Build Settings中暂时将Enable Bitcode设置为No来解决它。

解决： [ios - VSTS Build Generation throwing Invalid bitcode version error - Stack Overflow](https://stackoverflow.com/questions/51128462/vsts-build-generation-throwing-invalid-bitcode-version-error)

科普Bitcode: 

说的是bitcode是被编译程序的一种中间形式的代码。包含bitcode配置的程序将会在App store上被编译和链接。bitcode允许苹果在后期重新优化程序的二进制文件，而不需要重新提交一个新的版本到App store上。
当提交程序到App store上时，Xcode会将程序编译为一个中间表现形式(bitcode)。然后App store会再将这个botcode编译为可执行的64位或32位程序。

所以，如果我们的工程需要支持bitcode，则必要要求所有引入的第三方库都支持bitcode。
* [Xcode7新特性之bitcode - 雅香小筑 - CSDN博客](https://blog.csdn.net/mylizh/article/details/50499689)
* [What is app thinning? (iOS, tvOS, watchOS) - Xcode Help](https://help.apple.com/xcode/mac/current/#/devbbdc5ce4f)

    bitcode是什么鬼？以前咋没听过，在经过与度娘多次交涉之后终于有点明白了。

    我们知道，计算机软件必须要经过编译和链接过程，生成可执行代码之后才能够在设备上运行，要想弄明白bitcode是什么，就需要从编译器入手。

    传统的静态编译器工作过程可分为三个阶段：前端、优化和后端。


    而iOS代码使用的编译器是LLVM（关于LLVM后面会有专门的文章详细介绍），LLVM的三个阶段如下图所示：

    由上图可以看出，LLVM编译生成中间码IR（Intermediate Representation）,而非目标代码，这里所说的中间码IR就是我们想要知道的bitcode。


    使用中间码有以下三个优点：


    1. 如果需要支持一种新的编程语言，只需要实现一种新的前端；
    2. 如果需要支持一种新的硬件，只需要实现一种新的后端；
    3. 无论增加对新语言的支持，还是增加对新硬件的支持，中间的优化阶段都不需要改变；


    这样就实现了前后端的分离。


    由于上述优点，中间码已经被越来越多的编译器所采用，传统的编译器多采用汇编语言作为自己的中间语言，而现在大一些的编译器都有了自己专属的中间码。


    弄明白了bitcode是何方神圣之后，错误原因就不难找出：
    Xcode 7要求提交到AppStore的代码必须包含中间码（bitcode），而OpenCV属于第三方库，是之前从官网下     载的，在编译时并没有生成bitcode，所以链接时候找不到OpenCV的bitcode，因而报错。

##  代码
### 重复设置代码

发现首页第一个接口调用了2次，
是因为第一次调用了设置接口又加载了一次
![](https://i.loli.net/2018/11/02/5bdc25ec40877.jpg)

 
 
## 定时器单例
 
 > App设置了一个全局的定时器，需求是App切换到后台时，需要保存计时进度，

```objc
#pragma mark -  Func

// 创建全局队列计时器
- (void)startGlobalTimer{
    // 懒加载-创建一个定时器
    if (!self.globalQueue) {
    
        // 获取一个全局并发队列
        self.globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
        
        });
        
        // 首次启动定时器
        dispatch_resume(self.flowTime);
        self.isTimerStarted = YES;
    }
    
    // 恢复启动定时器
    if (!self.isTimerStarted) {

        /** 展示存储的进度 */
        // [self showStoredProgess]; // 无需调用

        dispatch_resume(self.flowTime);
        self.isTimerStarted = YES;
    }
}
```

### 说明

* 我每次存储上次的时间进度，然后在恢复启动器的时候，调用展示存储的进度的方法；
* **但是发现因为定时器是单例和App的生命周期几乎是一样的，所以它存储的时间作为它的属性也是自动保留的**，所以我觉得就无需调用这个`展示存储的进度`的方法了。
* 除非App被杀掉进程后，定时器也随之结束，然后需要在重启的时候获取存储的进度。

```objc
#pragma mark - Function

/** 展示存储的进度 */
- (void)showStoredProgess{
    // 获取上次缓存的进度时间
    NSInteger lastTimeSecond = [[AppArchiver sharedInstance] getStoreLastStayTimeSecond];
    if (lastTimeSecond >= TaskStayTimer_MaxCount || lastTimeSecond < 0) lastTimeSecond = 0;
    // 减去上次缓存的进度时间
    self.remainTime = self.remainTime - lastTimeSecond;
    
    // 初始化的时候显示进度动画
    CGFloat ticketProgress = 1.0 * (TaskStayTimer_MaxCount - self.remainTime) / TaskStayTimer_MaxCount;
    // 主线程设置按钮进度
    dispatch_async(dispatch_get_main_queue(), ^{
        BOOL isBtnHide = [TaskFloatBtn sharedInstanceBtn].isHidden;
        if (!isBtnHide) {
            [[TaskFloatBtn sharedInstanceBtn] setTicketProgress:ticketProgress animatied:true];
        }
    });
}
```
 
 
## 参考

1. [iphone - EXC_BAD_ACCESS in UIWebView - Stack Overflow](https://stackoverflow.com/questions/1520674/exc-bad-access-in-uiwebview)