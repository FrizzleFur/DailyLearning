

# 解析-设计模式

TODO:

* [面向对象设计的设计模式（三）：行为型模式（附 Demo 及 UML 类图） | J_Knight_](https://knightsj.github.io/2019/03/17/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/#more)
* [关于 23 种设计模式的有趣见解 - 文章 - 伯乐在线](http://blog.jobbole.com/20496/)

![](https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/20190314175913.png)
![](https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/20190314180004.png)

![](https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/20190314180054.png)

![](https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/20190314180150.png)

设计模式: MVC模式、单例模式、观察者模式、MWM模式、工厂模式、代理模式、策略模式、
适配器模式、模板模式、外观模式、创建模式

### MVC模式


mvc模式: model保存应用模型和处理数据逻辑、view 负责model数据和交互控件的显示、
controller负责model和View之间的通讯

### 单例模式

单例模式:用一个静态方法返回这个类的对象。系统只需要拥有一个的全局对象，这样有利于我
们协调系统整体的行为，这个对象是全局唯一-的。 整个项目里面之开辟一块内层、方便传值和修改单例的属性，比如登录之后获取的用户数据存储、NSNotificationcenter、 NSLJserdefaults,
sharedApplication缺点是这块内层直到项目推出时才能释放。应用场景:确保程序运行期某个
类，只有一份实例，用于进行资源共享控制。优势:使用简单，延时求值，易于跨模块敏捷原
则:单一职责原则注意事项:确保使用者只能通过getInstance方法才能获得，单例类的唯一实
例。java, C++中使其没有公有构造函数，私有化并覆盖其构造函数。object c中，重写.
allocWithZone方法，保证即使用户用alloc方法直接创建单例类的实例，返回的也只是此单例类
的唯-静态变量。

### MVVM模式

mvm模式: vm直接通讯一般使用RAC

视图(View)、视图模 型(ViewModel)、模型(Model)三部分组成
使用MVVM模式有几大好处:
1.低耦合。View可以独立于Model变化和修改，一个ViewModel可 以绑定到不同的View上，当
View变化的时候Model可以不变，当Model变化的时候View也可以不变 。
2.可重用性。可以把一些视图的逻辑放在ViewModel里面，让很多View重用这段视图逻辑。
3.独立开发。开发人员可以专注与业务逻辑和数据的开发(ViewModel)。设计人员可以专注于界
面(View)的设计。
4.可测试性。可以针对ViewModel来对 界面(View)进行测试
5.在ios上使用MWM的动机,就是让它能减少View Controller的复杂性并使得表示逻辑更易于
测试
6.将网络请求抽象到单独的类中
7.将界面的拼装抽象到专门的类中
8.构造ViewModel具体做法就是将ViewController 给View传递数据这个过程，抽象成构造
ViewModel的过程。抽象之后，View 只接受ViewModel,而Controller 只需要传递ViewModel
这么一行代码。而另外构造ViewModel的过程，我们就可以移动到另外的类中了。
9. MVC设计模式中的ViewController进一步拆分， 构造出网络请求层、ViewModel 层、Service
层、Storage 层等其它类，来配合Controller 工作，从而使Controller更加简单，我们的App更
容易维护。Controller 的代码抽取出来，是有助于我们做测试工作的。
10.ViewModel:存放各种业务逻辑和网络请求
在MVC里，View 是可以直接访问Model的!从而，View里会包含Model信息，不可避免的还要包
括一些业务逻辑。MVC模 型关注的是Model的不变，所以，在MVC模型里，Model不依赖于
View,但是View是依赖于Model的。不仅如此，因为有一些业务逻辑在View里实现了，导致要更
改View也是比较困难的，至少那些业务逻辑是无法重用的。
MWM在概念上是真正将页面与数据逻辑分离的模式，它把数据绑定工作放到一-个JS里去实现,
而这个JS文件的主要功能是完成数据的绑定，即把model绑定 到U的元素上。
有人做过测试:使用Angular (MWM)代替Backbone (MVC) 来开发，代码可以减少一半。
此外，MVM另一个重要特性，双向绑定。它更方便你同时维护页面上都依赖于某个字段的N个
区域，而不用手动更新它们。
总结:

优点: MWVM就是在MVC的基础上加入了一个视图模型viewModel,用于数据有效性的验证，视
图的展示逻辑，网络数据请求及处理，其他的数据处理逻辑集合，并定下相关接口和协议。相
比起MVC, MWM中vc的职责和复杂度更小，对数据处理逻辑的测试更加方便，对bug的原因排
查更加方便，代码可阅读性，重用性和可维护性更高。MVVM耦合性更低。MWM不同层级的职
责更加明确，更有利于代码的编写和团队的协作。缺点: MVVM相比MVC代码量有所增加。
MVVM相比MVC在代码编写之前需要有更清晰的模式思路。



(4)观察者模式
2.观察者模式:通过添加观察者来观察某个对象的实例变量的变化、当该被观察的对象的实例变
量发生时，观察者响应observeValueForKeyPath方法，如常用的导航栏渐变。应用场景:一般
为model层对controller和view进行的通知方式，不关心谁去接收，只负责发布信息。优势:解耦合敏捷原则:接口隔离原则，开放-封闭原则实例: Notification通知中心， 注册通知中心任何位置可以发送消息，注册观察者的对象可以接收。


### 工厂模式

3.工厂模式:快速创建对象的方式。将对象的创建和属性赋值封装成类方法，如:**创建常用按
钮、textFeild等，forState这些枚举值不用反复写， 可以使调用工厂方法的地方代码更加简洁。**
应用场景:工厂方式创建类的实例，多与proxy模式配合，创建可替换代理类。
优势:易于替换，面向抽象编程，application只与 抽象工厂和易变类的共性抽象类发生调用关
系。
敏捷原则: DIP依赖倒置原则
实例:项目部署环境中依赖多个不同类型的数据库时，需要使用工厂配合proxy完成易用性替换
注意事项:项目初期，软件结构和需求都没有稳定下来时，不建议使用此模式，因为其劣势也很
明显，
增加了代码的复杂度，增加了调用层次，增加了内存负担。所以要注意防止模式的滥用。
(6)代理模式
代理模式:代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。比如
一个工厂生产了产品，并不想直接卖给用户，而是搞了很多代理商，用户可以直接找代理商买东
西，代理商从工厂进货。常见的如QQ的自动回复就属于代理拦截，代理模式在iphone中得到广
泛应用。有点像c++中多继承。增加对象的方法和属性。代理模式使项目的逻辑结构比较直观,
比如tableView的delegate和DataSource。优势:解耦合敏捷原则:开放封闭原则。代理的目的
是改变或传递控制链，允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指


针,可以减少框架复杂度和耦合度。另外一点，代理可以理解为java中的回调监听机制的一种类
似。
### 策略模式
7.策略模式:把一些独立的算法单独封装起来，如我以前有个车管的app里面根据北斗定位步标
设备最后- -次上传数据库的时间和车辆状态，来解析车辆当前的状态，数据库中的16进制的状态
(应用的是交通部的808协议) , 移动端获得将此状态字段转换成2进制，判断出车辆的24中状
态。cell多种响应效果
应用场景:定义算法族，封装起来,使他们之间可以相互替换。优势:使算法的变化独立于使用
算法的用户
敏捷原则:接口隔离原则;多用组合，少用继承;针对接口编程，而非实现。
实例:排序算法，NSArray的sortedArrayUsingSelector; 经典的鸭子会叫，会飞案例。注意事
项: 1,剥离类中易于变化的行为，通过组合的方式嵌入抽象基类
变化的行为抽象基类为，所有可变变化的父类
用户类的最终实例，通过注入行为实例的方式，设定易变行为
(8)适配器模式
8.适配器模式:根据不同的场景选择不同的对象，不如接手了一个旧代码，一 进公司就得修改需
求，这时候的代码逻辑没法去反复理解，如我的一个老项目里面有-个认证功能将货主认证的
model和车主认证model放同一个model里面，现在需要增加货主认证model属性修改，此时就可
以使用适配器了，原来其他地方还是走货住认证，因为企业也是货主的一种，可以建一个新的货
主model新需求走新的货主认证。
(9)模版模式
9.模板模式:比如现在的项目建的基类baseViewController, base' TableViewController,
(10)外观模式
10.外观模式:专门为外部提供子类模块功能的api类，如果保险下单，只需要支付用你选的支付
方式和保险种类及填写的保险的必要信息一起传给下单的外观对象即可，在外观类里面封装了有
下单和支付两个子步簇，只需要将下保险的是否成功的结果返给下单界面就行。
(11)创建模式
11.创建模式:将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表
示，假如在一个工具对象内对轨迹点去重复、纠偏、漂移过滤等，例加-一个对象对外提供该时间
段轨迹停车时长和平均速度、平局耗油量等参数的接口。拿到数组点在地图上展示一下就可以
了，此数组对象的生成和使用可以分开。当然了这些复杂的操作都在服务端做了。
(12) MVP模式
MVP模式从经典的MVC模式演变而来，将Controller替 换成Presenter,依据MVP百度百科中的解
释，MVP的优点相比较于MVC是完全分离Model与View, Model与 View的信息传递只能通过
CotrllerPresenter,我查阅资料发现在其他平台上的MVC模式View与Model能否直接通讯有着
不同的说法，但在iOS开发中，Apple是这么说的。在MVC下，所有的对象被归类为一个model,
一个view, 或一个controller。 Model持 有数据，View 显示与用户交互的界面，而View Controller调
解Model和View之间的交互，在iOS开 发中我按照Model与View无法相互通讯来理解。

MVM中，我们将视图处理逻辑从C中剥离出来给V，剩下的业务逻辑部分被称做View-Model。
使用MWM模式的iOS应用的可测试性要好于MVC，因为ViewModel中并不 包含对View的更新，
相比于MVC,减轻了Controller的负担，使功能划分更加合理。
我们应该为app delegate的根视图创建一个ViewModel, 当我们要生成或展示另一一个次级
ViewController时，采用当前的ViewModel为其创建一个 子ViewModel。
viewModel tableView的布局实现，主要是计算行高。
ListViewModel加载网络数据，缓存图片，用调度组实现。监听下载完成，异步回调。



## 大话设计模式


[创建型模式 — Graphic Design Patterns](https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/creational.html#creational)

## 创建型模式

> 创建型模式(Creational Pattern)对**类的实例化过程进行了抽象**，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，**外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则**。

创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。**创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建**和组合在一起**达到使整个系统独立的目的**。


**包含模式**

* 简单工厂模式（Simple Factory）

    重要程度：4 （5为满分）

* 工厂方法模式（Factory Method）

    重要程度：5

* 抽象工厂模式（Abstract Factory）

    重要程度：5

* 建造者模式（Builder）

    重要程度：2

* 原型模式（Prototype）

    重要程度：3

* 单例模式（Singleton）

    重要程度：4


### 1.1 简单工厂模式（Simple Factory）


考虑一个简单的软件应用场景，一个软件系统可以提供多个外观不同的按钮（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，**只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象**，此时，就可以使用简单工厂模式。

#### 模式定义

简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。**在简单工厂模式中，可以根据参数的不同返回不同类的实例**。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

####  模式结构

简单工厂模式包含如下角色：

* Factory：工厂角色

    工厂角色负责实现创建所有实例的内部逻辑

* Product：抽象产品角色

    抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口

* ConcreteProduct：具体产品角色

    具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。

![](https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/20190309180226.png)



```
#include "Factory.h"
#include "ConcreteProductA.h"
#include "ConcreteProductB.h"
Product* Factory::createProduct(string proname){
	if ( "A" == proname )
	{
		return new ConcreteProductA();
	}
	else if("B" == proname)
	{
		return new ConcreteProductB();
	}
	return  NULL;
}
```

#### 模式分析

* 将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。
* 在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码。
* 简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。
* 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。


#### 简单工厂模式的优点


* 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。
* 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。
* 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。


#### 简单工厂模式的缺点

* 由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。
* 使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。
* **系统扩展困难，一旦添加新产品就不得不修改工厂逻辑**，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。
* 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。

#### 例子

比如计算器就是一个工厂，对`+ - * / `的算法封装

####  总结

* 创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。
* 简单工厂模式又称为静态工厂方法模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。
* 简单工厂模式包含三个角色：工厂角色负责实现创建所有实例的内部逻辑；抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口；具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。
* 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。
* 简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。
* 简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。




### 1.5 单例模式

单例模式(Singleton Pattern)：**单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法**。

单例模式的要点有三个：
* 一是某个类只能有一个实例；
* 二是它必须自行创建这个实例；
* 三是它必须自行向整个系统提供这个实例。
* 单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。


在单例模式的实现过程中，需要注意如下三点：

* 单例类的构造函数为私有；
* 提供一个自身的静态私有成员变量；
* 提供一个公有的静态工厂方法。



```objc
static id obj = nil;
+(instancetype)shareInstance
{
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        obj = [[SingletonObj alloc] init];
    });
    return obj;
}
```

dispatch_once可以用来初始化一些全局的数据，它能够确保block代码在app的生命周期内仅被运行一次，而且还是线程安全的，不需要额外加锁；predicate必须指向一个全局或者静态的变量，不过使用predicate的话结果是未定义的，不过predicate有啥作用，如何实现block在整个生命周期执行一次？那我们只能从源码查找(源码地址：once)。

让我们来看看dispatch_once是如何确保block只执行一次。简单来说，当线程A在调用执行block并设置predicate为DISPATCH_ONCE_DONE(~0l)期间，如果有其他线程也在调用disptach_once，则这些线程会等待，各线程对应的信号量会加入到信号量链表中，等predicate设置为DISPATCH_ONCE_DONE后，也就是block执行完了，会根据信号量链表唤醒各个线程使其继续执行。

![](https://pic-mike.oss-cn-hongkong.aliyuncs.com/qiniu/15328740834705.jpg)

  现在我们清楚dispatch_once是如何确保block只执行一次了，关键就在predict这个值，通过比较这个值等于0或者~0l来判断block是否执行过，这也就是为啥我们需要将这个值设为static或者全局的缘故，因为各个线程都要去访问这个predict，有兴趣的可以试试把predicate的初始值设为非0或者非静态全局变量会发生什么～～

#### 单例模式优点

* 提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。
* 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。
* 允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。

#### 单例模式缺点

* 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。
* 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。
* 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。

使用synchronized方法实现：

```objc
static id obj = nil;
+(instancetype)shareInstance
{
    @synchronized(self) {
        if (!obj) {
            obj = [[SingletonObj alloc] init];
        }
    }
    return obj;
}
```

翻看苹果的文档可以发现 @synchronized指令内部使用锁来实现多线程的安全访问，并且隐式添加了一个异常处理的handler，当异常发生时会自动释放锁。在stackoverflow上看到@synchronized指令其实可以转换成objc_sync_enter跟objc_sync_exit，可以在<objc/objc-sync.h>头文件中找到这两个函数:


```objc
//Allocates recursive pthread_mutex associated with 'obj' if needed
int objc_sync_enter(id obj)

//End synchronizing on 'obj'
int objc_sync_exit(id obj)

```根据注释文档，objc_sync_enter会根据需要给每个传进来的对象创建一个互斥锁并lock，然后objc_sync_exit的时候unlock，这样就可以通过这个锁来实现多线程的安全访问，所以结合苹果文档可以认为

```objc
@synchronized(self) {
    //thread safe code
}
等价于

@try {
    objc_sync_enter(self);
    // thread safe code
} @finally {
    objc_sync_exit(self);    
}
```


## 结构型模式

结构型模式(Structural Pattern)描述如何将类或者对 象结合在一起形成更大的结构，就像搭积木，可以通过 简单积木的组合形成复杂的、功能更为强大的结构。

结构型模式可以分为类结构型模式和对象结构型模式：

* 类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系。 
* 对象结构型模式关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。
*  根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是对象结构型模式。

**包含模式**

* 适配器模式(Adapter), 重要程度：4

* 桥接模式(Bridge), 重要程度：3

* 组合模式(Composite), 重要程度：4

* 装饰模式(Decorator), 重要程度：3

* 外观模式(Facade), 重要程度：5

* 享元模式(Flyweight), 重要程度：1

* 代理模式(Proxy), 重要程度：4


### 2.1 适配器模式

* 在软件开发中采用类似于电源适配器的设计和编码技巧被称为适配器模式。
* 通常情况下，客户端可以通过目标类的接口访问它所提供的服务。有时，现有的类可以满足客户类的功能需要，但是它所提供的接口不一定是客户类所期望的，这可能是因为现有类中方法名与目标类中定义的方法名不一致等原因所导致的。
* 在这种情况下，现有的接口需要转化为客户类期望的接口，这样保证了对现有类的重用。如果不进行这样的转化，客户类就不能利用现有类所提供的功能，适配器模式可以完成这样的转化。
* 在适配器模式中可以定义一个包装类，包装不兼容接口的对象，这个包装类指的就是适配器(Adapter)，它所包装的对象就是适配者(Adaptee)，即被适配的类。
* 适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。


#### 模式定义

适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。


#### 模式结构

适配器模式包含如下角色：

* Target：目标抽象类
* Adapter：适配器类
* Adaptee：适配者类
* Client：客户类


对象适配器：

![](https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/20190310115724.png)


类适配器：

![](https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/20190310115755.png)



#### 例子

```objc

// 定义一个target类

@interface HCDPlayer : NSObject
@property(nonatomic,copy)NSString *name;
-(void)attack;
-(void)defense;
-(instancetype)initWithName:(NSString *)name;
@end

// 一个需要适配的类Adaptee，和target类不一样的类

@interface HCDForeignCenter : NSObject
@property(nonatomic,copy)NSString *name;
-(void)foreignAttact;
-(void)foreignDefent;
-(instancetype)initWithName:(NSString *)name;
@end

// 继承target类的适配器，适配Adaptee类，转为target类

@interface HCDTranslator ()

@end
@implementation HCDTranslator
-(instancetype)initWithName:(NSString *)name{
    self = [super init];
    if (self) {
        _foreigncenter = [[HCDForeignCenter alloc]initWithName:name];
    }
    return self;
}

-(void)defense{
    [self.foreigncenter foreignDefent];
}
-(void)attack{
    [self.foreigncenter foreignAttact];
}
@end

// 这样就可以通过适配器Adapter出来的类，实现产出同样的target对象

HCDPlayer *forward = [[HCDForwards alloc]initWithName:@"maidi"];
[forward attack];
[forward defense];
HCDPlayer *foreignCenter = [[HCDTranslator alloc]initWithName:@"姚明"];
[foreignCenter attack];
[foreignCenter defense];

```

#### 适配器优点

* 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。
* 增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。
* 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。
* 类适配器模式还具有如下优点：
    * 由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。
* 对象适配器模式还具有如下优点：
    * 一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。

#### 适配器缺点

* 类适配器模式的缺点如下：
    * 对于Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，其使用有一定的局限性，不能将一个适配者类和它的子类都适配到目标接口。
* 对象适配器模式的缺点如下：
    * 与类适配器模式相比，要想置换适配者类的方法就不容易。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。


### 2.2 桥接模式

设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：

* 第一种设计方案是为每一种形状都提供一套各种颜色的版本。
* 第二种设计方案是根据实际需要对形状和颜色进行组合
* 
对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。**设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量**。


##### 模式定义

桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。


##### 模式结构

桥接模式包含如下角色：

* Abstraction：抽象类
* RefinedAbstraction：扩充抽象类
* Implementor：实现类接口
* ConcreteImplementor：具体实现类

![](https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/20190310115709.png)


### 2.3 装饰模式

#### 模式动机

一般有两种方式可以实现给一个类或对象增加行为：

* 继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。
* 关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)
装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。这就是装饰模式的模式动机。

#### 模式定义

装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”，它是一种对象结构型模式。

#### 应用

iOS中的`category`的类拓展就是应用了装饰模式

#### 模式结构

装饰模式包含如下角色：

* Component: 抽象构件
* ConcreteComponent: 具体构件
* Decorator: 抽象装饰类
* ConcreteDecorator: 具体装饰类

![](https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/20190310120526.png)


#### 装饰模式的优点:

* 装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。
* 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。
* 通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。
* 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”

#### 装饰模式的缺点:

* 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。
* 这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。

#### 装饰模式总结

* 装饰模式用于动态地给一个对象增加一些额外的职责，就增加对象功 能来说，装饰模式比生成子类实现更为灵活。它是一种对象结构型模 式。
* 装饰模式包含四个角色：抽象构件定义了对象的接口，可以给这些对 象动态增加职责（方法）；具体构件定义了具体的构件对象，实现了 在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）； 抽象装饰类是抽象构件类的子类，用于给具体构件增加职责，但是具 体职责在其子类中实现；具体装饰类是抽象装饰类的子类，负责向构 件添加新的职责。
* 使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动 态地给一个对象附加更多的责任。装饰模式可以在不需要创造更多子 类的情况下，将对象的功能加以扩展。
* 装饰模式的主要优点在于可以提供比继承更多的灵活性，可以通过一种动态的 方式来扩展一个对象的功能，并通过使用不同的具体装饰类以及这些装饰类的 排列组合，可以创造出很多不同行为的组合，而且具体构件类与具体装饰类可 以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类；其主要缺 点在于使用装饰模式进行系统设计时将产生很多小对象，而且装饰模式比继承 更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需 要逐级排查，较为烦琐。
* 装饰模式适用情况包括：在不影响其他对象的情况下，以动态、透明的方式给 单个对象添加职责；需要动态地给一个对象增加功能，这些功能也可以动态地 被撤销；当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展 和维护时。
* 装饰模式可分为透明装饰模式和半透明装饰模式：在透明装饰模式中，要求客 户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该声明具体构 件类型和具体装饰类型，而应该全部声明为抽象构件类型；半透明装饰模式允 许用户在客户端声明具体装饰者类型的对象，调用在具体装饰者中新增的方法。

### 2.5 享元模式


* 面向对象技术可以很好地解决一些灵活性或可扩展性问题，但在很多情况下需要在系统中增加类和对象的个数。当对象数量太多时，将导致运行代价过高，带来性能下降等问题。

* 享元模式正是为解决这一类问题而诞生的。享元模式通过共享技术实现相同或相似对象的重用。
* 在享元模式中可以共享的相同内容称为内部状态(IntrinsicState)，而那些需要外部环境来设置的不能共享的内容称为外部状态(Extrinsic State)，由于区分了内部状态和外部状态，因此可以通过设置不同的外部状态使得相同的对象可以具有一些不同的特征，而相同的内部状态是可以共享的。
* 在享元模式中通常会出现工厂模式，需要创建一个享元工厂来负责维护一个享元池(Flyweight Pool)用于存储具有相同内部状态的享元对象。
* 在享元模式中共享的是享元对象的内部状态，外部状态需要通过环境来设置。在实际使用中，能够共享的内部状态是有限的，因此享元对象一般都设计为较小的对象，它所包含的内部状态较少，这种对象也称为细粒度对象。享元模式的目的就是使用共享技术来实现大量细粒度对象的复用。

#### 模式定义

享元模式(Flyweight Pattern)：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。

#### 模式结构

享元模式包含如下角色：

* Flyweight: 抽象享元类
* ConcreteFlyweight: 具体享元类
* UnsharedConcreteFlyweight: 非共享具体享元类
* FlyweightFactory: 享元工厂类

一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费。


### 2.6 代理模式

在某些情况下，一个客户不想或者不能直接引用一个对 象，此时可以通过一个称之为“代理”的第三者来实现 间接引用。代理对象可以在客户端和目标对象之间起到 中介的作用，并且可以通过代理对象去掉客户不能看到 的内容和服务或者添加客户需要的额外服务。


通过引入一个新的对象（如小图片和远程代理 对象）来实现对真实对象的操作或者将新的对 象作为真实对象的一个替身，这种实现机制即 为代理模式，通过引入代理对象来间接访问一 个对象，这就是代理模式的模式动机。

#### 模式定义

代理模式(Proxy Pattern) ：给某一个对象提供一个代 理，并由代理对象控制对原对象的引用。代理模式的英 文叫做Proxy或Surrogate，它是一种对象结构型模式。

#### 模式结构

代理模式包含如下角色：

* Subject: 抽象主题角色
* Proxy: 代理主题角色
* RealSubject: 真实主题角色

![](https://pic-mike.oss-cn-hongkong.aliyuncs.com/Blog/20190310121826.png)

#### 代理模式优点

* 代理模式能够协调调用者和被调用者，在一定程度上降低了系 统的耦合度。
* 远程代理使得客户端可以访问在远程机器上的对象，远程机器 可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。
* 虚拟代理通过使用一个小对象来代表一个大对象，可以减少系 统资源的消耗，对系统进行优化并提高运行速度。
* 保护代理可以控制对真实对象的使用权限。

#### 代理模式缺点

* 由于在客户端和真实主题之间增加了代理对象，因此 有些类型的代理模式可能会造成请求的处理速度变慢。
* 实现代理模式需要额外的工作，有些代理模式的实现 非常复杂。


####  block 和 Delegate

* 代理和 block 实际上都是函数 imp 的调用，但区别是，代理就等价于 weak 持有一个代理对象，你不写 protocol 不写 delegate ，一股脑把所有方法全写在 header 里，然后把代理对象本身直接传过去给另一个对象，在另一个对象中 weak 持有这个代理对象，这种写法和代理是没有区别的。

* 而 block 是一种还原上下文环境，甚至自动包裹一些自由变量的闭包概念，换句话说，block 的回调代码，和写 block 的代码，是可以同处于一个函数内，在一个可读代码上下文内，即 block 在代码上是一个连续的过程。

* 代理方法实际上传值传的是一整个对象，你把 a.delegate = self 其实是把 self 传给了 a 持有，跟一般的属性赋值无异，如果再次传递，完全可以继续传递 self 给别人。

* block 继续传递，实际上是把 imp 和上下文环境的自动变量打包进行传递，这个过程中不一定会传递一个对象。从这个角度看 block 的控制力度更强一些。

* 这里会涉及到一个安全性方面的考虑，你把 self 传给了一个不知名的三方库，他虽然只是 id 看起来只能调用 protocol 里限定的方法，但其实 OC 这个约束只是骗骗编译器的。如果你把一个 self 传给了一个三方，设定为代理，如果三方有其他意图，他其实可以直接控制你的 self 对象的任意值或者方法。但 block ，你传过去的 block ，他只能操作 block 本身包裹的上下文环境。


## 行为型模式


行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。

行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。

通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象 之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。

行为型模式分为类行为型模式和对象行为型模式两种：

*   类行为型模式：类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。
*   对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。

**包含模式**

*   职责链模式(Chain of Responsibility)

    重要程度：3

*   命令模式(Command)

    重要程度：4

*   解释器模式(Interpreter)

    重要程度：1

*   迭代器模式(Iterator)

    重要程度：5

*   中介者模式(Mediator)

    重要程度：2

*   备忘录模式(Memento)

    重要程度：2

*   观察者模式(Observer)

    重要程度：5

*   状态模式(State)

    重要程度：3

*   策略模式(Strategy)

    重要程度：4

*   模板方法模式(Template Method)

    重要程度：3

*   访问者模式(Visitor)

    重要程度：1


### 中介者模式

#### 模式定义

中介者模式(Mediator Pattern)定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。

#### 模式应用

MVC架构中控制器

### 观察者模式

#### 模式动机


建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。

#### 模式定义


观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。

观察者模式是一种对象行为型模式。

#### 模式结构


观察者模式包含如下角色：

* Subject: 目标
* ConcreteSubject: 具体目标
* Observer: 观察者
* ConcreteObserver: 具体观察者

#### 模式分析

* 观察者模式描述了如何建立对象与对象之间的依赖关系，如何构造满足这种需求的系统。
* 这一模式中的关键对象是观察目标和观察者，一个目标可以有任意数目的与之相依赖的观察者，一旦目标的状态发生改变，所有的观察者都将得到通知。
* 作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步，这种交互也称为发布-订阅(publishsubscribe)。目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通

#### 观察者模式的优点

* 观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。
* 观察者模式在观察目标和观察者之间建立一个抽象的耦合。
* 观察者模式支持广播通信。
* 观察者模式符合“开闭原则”的要求。

#### 观察者模式的缺点

* 如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
* 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
* 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

#### 观察者模式应用

MVC模式是一种架构模式，它包含三个角色：模型(Model)，视图(View)和控制器(Controller)。观察者模式可以用来实现MVC模式，观察者模式中的观察目标就是MVC模式中的模型(Model)，而观察者就是MVC中的视图(View)，控制器(Controller)充当两者之间的中介者(Mediator)。当模型层的数据发生改变时，视图层将自动改变其显示内容。


### 策略模式


#### 模式动机

*   完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。
*   在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。
*   在软件系统中，有许多算法可以实现某一功能，如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。
*   除了提供专门的查找算法类之外，还可以在客户端程序中直接包含算法代码，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。
*   为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类。

####  模式定义

策略模式(Strategy Pattern)：**定义一系列算法，将每一个算法封装起来，并让它们可以相互替换**。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。

策略模式是一种对象行为型模式。

#### 模式结构

策略模式包含如下角色：

*   Context: 环境类
*   Strategy: 抽象策略类
*   ConcreteStrategy: 具体策略类


## 参考

1. [细说@synchronized和dispatch_once - 简书](https://www.jianshu.com/p/ef3f77c8b320)
2. [由 NSObject *obj 引发的一二事儿 - 掘金](https://juejin.im/post/5b63b857e51d455f5f4d1d74)



# iOS 设计模式 Design Patterns

## 常见设计模式

> App开发过程中，随着业务的不断发展，代码和逻辑不断增加，有时候不得不重构以前的代码，好的架构，利于代码的拓展和重构，下面就简单探讨一下`iOS`中常见的设计模式吧。

![设计模式](http://upload-images.jianshu.io/upload_images/225323-084955b97a69fd9d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### MVC

> 一个简单的举例

![](https://i.loli.net/2018/10/21/5bcc88930ebf8.jpg)

通信方式

![](https://i.loli.net/2018/10/21/5bcc88ba9690b.jpg)


* 初期：依据`MVC`模式，把项目进行`Model`、`View`、`Controller`简单分类：

![](http://upload-images.jianshu.io/upload_images/225323-538dc5ac5e0c8a35.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 中期：业务模块增加了，`Model`、`View`、`Controller`越来越多，于是，根据业务模块的分类，在每个模块内使用`MVC`模式：

![](http://upload-images.jianshu.io/upload_images/225323-61a4cca94b1f01db.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 后期：`MVC`模式还是没有干净、很好地分割模块，在`用户点击`、`网络请求`和`JSON解析数据`这些方面，会有交叉重叠的地方：

![](http://upload-images.jianshu.io/upload_images/225323-ee8cdb09cd5ca3db.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![](http://upload-images.jianshu.io/upload_images/225323-cc86545bb5394e2c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



###  MVC-N

把项目分为四类：`Model`、`View`、`Controller`、`Networking`：

![MVC-N](http://upload-images.jianshu.io/upload_images/225323-3f6e8b026875bc98.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### MVVM

上面`MVC-N`新建了一个模块，来管理网络请求，然而，获取数据后的数据解析，还是放在了`Controller`中，如何让`Controller`专注于用户交互呢？而`MVVM`模式，添加了`ViewModel`来管理数据解析和网络请求等，解决了这个问题。

在`MVVM`中，`Controller`依然存在，但是不再直接持有`Model`，`Controller`持有`ViewModel`，`Model`被交给`ViewModel`管理。

![MVVM](http://upload-images.jianshu.io/upload_images/225323-7cfd7fb099155bb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


###  Multicast Closure DelegateNEW


代理模式大家应该最熟悉了，`UIKit`中很多，经典的`UITableViewDelegate`、`UIAlertViewDelegate`. 基本原理是定一个协议`Protocol`，列出需要实现的方法协议，然后交给指定的代理实现，可以有多个代理，为了避免循环引用，代理`delegate`的属性设为`weak`,

####  多播委托（MulticastDelegate）

        多播委托（MulticastDelegate）继承自 `Delegate` ，表示多路广播委托；即，其调用列表中可以拥有多个元素的委托。实际上，我们自定义的委托的基类就是 `MulticastDelegate`。

![多播委托](http://upload-images.jianshu.io/upload_images/225323-d2526c31853c0bae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

假如现在有一个需求，我们以图片下载为例。这里先忽略哪些`SDWebimage`等已经封装好的第三方类库。对于图片下载一般的过程如下：

1. 先判断该图片`url`是否已经下载完毕。如果已经下载完毕那么直接回调显示图片。如果没有下载那么进入下载过程。
2. 使用合适的图片下载器下载图片。
3. 图片下载完毕后回调显示图片。并且把该图片存到缓存中。

这里的难点是回调。如果一个页面中有多个地方需要显示同一张图片，那么势必会发生这样一种情况，就是同时有多个请求下载同意url的图片，并且下载完成后需要同时在多个地方显示图片。要是实现这样的需求，用现有的方案貌似很难解决。有的同学会想到通知中心，但是通知中心其实是一个广播服务，只要注册了接受该通知那么所有的注册者都能收到通知，但事实上我只需要在我需要下载的那个url的图片下载完后给出通知，而不需要所有的下载完毕事件都通知。这时候我们就需要多播委托了。

普通的`delegate`只能是一对一的回调，无法做到一对多的回调。而多播委托正式对`delegate`的一种扩展和延伸，多了一个注册和取消注册的过程，任何需要回调的对象都必须先注册。比较经典的就是`XMPPframework `这个框架，用了很多多播委托模式（`GCDMulticastDelegate`）。


####  多播闭包委托

多播闭包委托 （Multicast Closure Delegate）继承自多播委托。

![多播闭包委托](http://upload-images.jianshu.io/upload_images/225323-095d1ffe6698fbcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## [附]设计原则

* [设计模式六大原则（1）：单一职责原则](http://www.uml.org.cn/sjms/201211023.asp#1)

* [设计模式六大原则（2）：里氏替换原则](http://www.uml.org.cn/sjms/201211023.asp#2)

* [设计模式六大原则（3）：依赖倒置原则](http://www.uml.org.cn/sjms/201211023.asp#3)

* [设计模式六大原则（4）：接口隔离原则](http://www.uml.org.cn/sjms/201211023.asp#4)

* [设计模式六大原则（5）：迪米特法则](http://www.uml.org.cn/sjms/201211023.asp#5)

* [设计模式六大原则（6）：开闭原则](http://www.uml.org.cn/sjms/201211023.asp#6)

## 总结

个人觉得，一种设计模式代表的是一种思想。平时开发的过程中，**尽量根据业务需求和已有的代码结构，参考成熟的设计模式，选取最适合当前的需求的模式**，而这些优秀的模式也是建立在不断的`Code Review`和对对代码的`Deep Thinking`的基础上，不断优化的成果，值得借鉴。

## 参考

1. [iOS Design Patterns - Part 2: Project Setup | Ray Wenderlich](https://videos.raywenderlich.com/courses/72-ios-design-patterns/lessons/2)

2. [设计模式六大原则](http://www.uml.org.cn/sjms/201211023.asp)
3. [前端你别闹](https://mp.weixin.qq.com/s?__biz=MzI5ODM3MjcxNQ==&mid=2247483943&idx=1&sn=d2b019ae41d8bd63d42f5abd0df64173&chksm=eca79923dbd01035b4038e8c513075ed5dcf201659cfca291125f45b4491fa96cf8b6f023a50&scene=21#wechat_redirect)

